# Runtime Spec（性能最優先）

このドキュメントは、Vitrioが進化しても **できるだけ変えない（安定させる）ランタイム挙動** をまとめたものなん。
パフォーマンスを守りつつ、うっかり意味がズレるのを防ぐためにある。

> 対象: `@potetotown/vitrio` のランタイム（リアクティブ、スケジューリング、effect、cleanup）
> 非目標: React APIの互換。Vitrioは **React代替** を目指すが、Reactのクローンではない。

## コア原則

1. **細粒度リアクティブ**: 実際に読んだ依存先にだけ更新が伝播する
2. **VDOM差分よりDOM直更新**: ノードは一度作って、バインディング更新で差分を当てる
3. **性能最優先のセマンティクス**: 無駄な通知・伝播を避ける
4. **WASMは任意の加速**: 正しさはWASMに依存しない

---

## リアクティブモデル

### Atom

- *Atom* はリアクティブなセル。
- `get(atom)` は現在値を返す。
- 追跡中（tracking中）に `get(atom)` された場合、現在のsubscriberがそのatomに依存する。

### 派生値（derive）

- `derive(fn)` は派生atomを作る。
- `fn` の中で `get()` された依存が追跡される。
- 派生atomは上流の変更で **push型に更新**される（伝播時に影響範囲の派生が再評価される）。
  - 内部実装でメモ化することはあっても、観測上は「依存が変われば前方へ伝播して値が更新される」モデル。

### 依存追跡

- 依存追跡はリアクティブ文脈（renderバインディング、effectなど）で自動。
- `untrack(fn)` は依存記録なしで `fn` を実行する。

---

## 更新セマンティクス

### `set(atom, next)`

1. 次の値を計算:
   - `next` が関数なら `computed = next(prev)`
   - それ以外なら `computed = next`
2. `Object.is(prev, computed)` が `true` の場合:
   - **状態は変わらない**
   - **通知しない**
   - **依存伝播しない**
3. それ以外は値を更新し、伝播をスケジュールする。

> `Object.is` による同値ショートサーキットは、性能契約の一部。

### バッチ & flush

- `batch(fn)` は複数の `set()` をまとめる。
- バッチ中は通知を溜める。
- 最外の `batch()` を抜けたら flush をスケジュール。

**flushのタイミング**
- デフォルトは **microtask**（例: `queueMicrotask`）でまとめてflushする（更新バーストを潰す）。

---

## Effects & Cleanup

### `createEffect(fn)`

- `fn` を追跡コンテキストで実行する。
- 依存が変わったら `fn` を再実行。
- cleanup:
  - `onCleanup()` で登録されたcleanupは **次回の再実行前** に走る
  - root/subscriber が dispose されるときにも走る

### `createRoot(fn)`

- 独立したリアクティブrootを作る。
- dispose時:
  - 通知を止める
  - cleanupを走らせる
  - 購読を解放する

---

## DOMバインディング

- UI更新は **最小のDOMノード差分**だけにする。
- DOMノードが削除されたら、関連する購読/cleanupも破棄される必要がある。

---

## WASM連携

- WASMは依存グラフ処理（例: 伝播）を加速するために使ってよい。
- **正しさはWASMに依存しない。**
- WASMのロード/初期化に失敗しても、JS実装で動作継続する。

---

## 互換性メモ

- VitrioはReact hooks互換を保証しない。
- 目標は「Reactで作るタイプのアプリ（routing/async UI/boundary）を作れる」ことで、より小さく速いランタイムを提供すること。
