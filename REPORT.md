# V言語のWeb Frontend利用に関する調査報告

V言語のJSおよびWASMビルドを試し、ファイルサイズや最適化について調査しました。また、mizchi氏が開発しているとされるWeb Componentsベースのフレームワーク（Luna/Moonbit）との比較についても考察しました。

## 調査結果: V言語のビルドサイズと特性

シンプルなフィボナッチ数列計算プログラム(`src/main.v`)を使用して検証しました。

### JavaScriptビルド (`v -b js`)

*   **開発ビルド**: 約154KB
*   **本番ビルド (`-prod`)**: 約131KB
*   **動作確認**: Node.jsで動作確認済み。
*   **所感**: ランタイムが含まれるため、「Hello World」レベルとしてはやや大きめですが、実用的なWebアプリケーションとしては許容範囲内と考えられます。生成されるJSは可読性があり、既存のJSエコシステムとの連携もしやすい形式です。

### WebAssemblyビルド (`v -b wasm`)

*   **開発ビルド**: 約4.4KB
*   **本番ビルド (`-prod`)**: 約1.7KB
*   **所感**:
    *   **サイズ**: 非常に軽量です。GoやBlazorのような重厚なランタイムを含まないため、RustやCに近いサイズ感です。
    *   **使い勝手**: デフォルトでは`.wasm`ファイルのみが生成され、それを読み込むためのJavaScriptグルーコード（ローダー）は自動生成されません。実際にWebで使用するには、`WebAssembly.instantiateStreaming`などを使って自前でロード処理を書く必要があります。
    *   **最適化**: `-prod`オプションをつけることで、`binaryen` (wasm-opt) による最適化が行われ、サイズが半分以下になりました。

## 考察: mizchi氏のLuna (Moonbit) との比較

mizchi氏が開発中の「Luna」（GitHub上の活動履歴からMoonbit製のUIフレームワークと推測されます）と、V言語のWASMを比較・考察します。

### 1. アプローチの類似性
両者ともに**「軽量なWASM生成」「既存の重いランタイム（GC等）を持たない」**という点で非常に似たアプローチを取っています。
MoonbitもVも、GoやC#のように重いランタイムをWASMに含める必要がないため、**Web Components (Custom Elements)** のような小さな単位での利用に適しています。

### 2. サイズ感
*   **Moonbit**: 「Hello World」が数百バイト〜1KB程度と極めて小さいことで知られています。
*   **V言語**: 今回の検証で約1.7KB (prod) でした。Moonbitには及びませんが、十分に「極小」の部類に入ります。React等の既存JSフレームワークと比較すれば圧倒的に軽量です。

### 3. Web Components (DOM) との連携
*   **Luna (Moonbit)**:
    *   mizchi氏のアプローチは、WASMを「ロジック」として使い、DOM操作はWeb Componentsのインターフェースを通じて効率よく行うものと推測されます。
    *   MoonbitにはJS FFI（`mizchi/js.mbt`など）があり、これを活用してDOM操作をラップしていると思われます。
*   **V言語**:
    *   VのWASMもJS関数をインポート(`fn JS.foo()`)して呼び出すことが可能です。
    *   ただし、現状では標準的な「Web Components作成キット」のようなものはなく、自分で`HTMLElement`を定義するJavaScriptコード（グルーコード）を書き、そこからVの関数を呼ぶ形になります。
    *   Vの`examples/wasm`には、JS側で定義した関数をVから呼ぶ例が存在します。

### 結論
V言語のWASMでも、mizchi氏のLunaと同様の**「Web Componentsベースの超軽量Webフロントエンド」**を実現することは**十分に可能**です。
ただし、V言語にはまだLunaのような「Web Components特化フレームワーク」が確立されていないため、同等の開発体験を得るには、DOM連携部分のライブラリ（グルーコードの抽象化レイヤー）を自作する必要があります。

以上
