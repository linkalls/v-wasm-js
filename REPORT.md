# V言語のWeb Frontend利用に関する調査報告

V言語のJSおよびWASMビルドを試し、ファイルサイズや最適化について調査しました。また、mizchi氏が開発しているとされるWeb Componentsベースのフレームワーク（Luna/Moonbit）との比較についても考察しました。

## 調査結果: V言語のビルドサイズと特性

シンプルなフィボナッチ数列計算プログラム(`src/main.v`)を使用して検証しました。

### JavaScriptビルド (`v -b js`)

*   **開発ビルド**: 約154KB
*   **本番ビルド (`-prod`)**: 約131KB
*   **動作確認**: Node.jsで動作確認済み。
*   **所感**: ランタイムが含まれるため、「Hello World」レベルとしてはやや大きめですが、実用的なWebアプリケーションとしては許容範囲内と考えられます。生成されるJSは可読性があり、既存のJSエコシステムとの連携もしやすい形式です。

### WebAssemblyビルド (`v -b wasm`)

*   **開発ビルド**: 約4.4KB
*   **本番ビルド (`-prod`)**: 約1.7KB
*   **所感**:
    *   **サイズ**: 非常に軽量です。GoやBlazorのような重厚なランタイムを含まないため、RustやCに近いサイズ感です。
    *   **使い勝手**: デフォルトでは`.wasm`ファイルのみが生成され、それを読み込むためのJavaScriptグルーコード（ローダー）は自動生成されません。実際にWebで使用するには、`WebAssembly.instantiateStreaming`などを使って自前でロード処理を書く必要があります。
    *   **最適化**: `-prod`オプションをつけることで、`binaryen` (wasm-opt) による最適化が行われ、サイズが半分以下になりました。

## 考察: mizchi氏のLuna (Moonbit) との比較

mizchi氏が開発中の「Luna」（GitHub上の活動履歴からMoonbit製のUIフレームワークと推測されます）と、V言語のWASMを比較・考察します。

### 1. アプローチの類似性
両者ともに**「軽量なWASM生成」「既存の重いランタイム（GC等）を持たない」**という点で非常に似たアプローチを取っています。
MoonbitもVも、GoやC#のように重いランタイムをWASMに含める必要がないため、**Web Components (Custom Elements)** のような小さな単位での利用に適しています。

### 2. サイズ感
*   **Moonbit**: 「Hello World」が数百バイト〜1KB程度と極めて小さいことで知られています。
*   **V言語**: 今回の検証で約1.7KB (prod) でした。Moonbitには及びませんが、十分に「極小」の部類に入ります。React等の既存JSフレームワークと比較すれば圧倒的に軽量です。

### 3. Web Components (DOM) との連携
*   **Luna (Moonbit)**:
    *   mizchi氏のアプローチは、WASMを「ロジック」として使い、DOM操作はWeb Componentsのインターフェースを通じて効率よく行うものと推測されます。
    *   MoonbitにはJS FFI（`mizchi/js.mbt`など）があり、これを活用してDOM操作をラップしていると思われます。
*   **V言語**:
    *   VのWASMもJS関数をインポート(`fn JS.foo()`)して呼び出すことが可能です。
    *   ただし、現状では標準的な「Web Components作成キット」のようなものはなく、自分で`HTMLElement`を定義するJavaScriptコード（グルーコード）を書き、そこからVの関数を呼ぶ形になります。
    *   Vの`examples/wasm`には、JS側で定義した関数をVから呼ぶ例が存在します。

## 実践: V言語でのWeb Component作成 (PoC)

実際に「Luna」のようなWeb ComponentをVで作成する実験を行いました（`src/luna_v_test/`参照）。

### 実装内容
*   **V側 (`src/luna_v_test/main.v`)**:
    *   状態（カウンタ）を保持。
    *   `get_html()`: 現在の状態に基づいたHTML文字列を生成して返す。
    *   `increment()`: 状態を更新する。
*   **JS側 (`src/luna_v_test/index.html`)**:
    *   Custom Element `<my-counter>` を定義。
    *   WASMをロードし、Vの関数を呼んで`innerHTML`を書き換える。

### 開発体験と課題
実際に開発してみて、以下の課題が明らかになりました：

1.  **グルーコードの自作が必要**:
    Moonbitの`mizchi/js`のように、JSのオブジェクトやDOMを直感的に扱える標準ライブラリがVのWASM環境にはまだ整備されていません。文字列の受け渡し（メモリ管理、UTF-8デコード）やDOMイベントのハンドリングをすべて手動で実装する必要があります。

2.  **コンパイラの安定性 (WASM)**:
    今回のPoC作成中、少し複雑なコード（グローバル変数や文字列操作）を書くと、生成されたWASMがブラウザやNode.jsでロードエラー（スタックアンダーフロー等）を起こしたり、`wasm-opt`がクラッシュする現象に遭遇しました。VのWASMバックエンドはまだ実験的な段階（beta/alpha）であると感じられます。

### 結論
V言語のWASMでも、mizchi氏のLunaと同様の**「Web Componentsベースの超軽量Webフロントエンド」**を実現することは**理論的には可能**です。
しかし、現時点では**コンパイラの安定性とライブラリのエコシステム**においてMoonbitに一日の長があるようです。
Vで同様のことを行うには、安定したWASM生成と、DOM操作を抽象化するラッパーライブラリの整備が待たれます。

以上
