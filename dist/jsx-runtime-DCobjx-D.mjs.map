{"version":3,"file":"jsx-runtime-DCobjx-D.mjs","names":["initVsignal"],"sources":["../src/vsignal.wasm","../src/core.ts","../src/jsx-runtime.ts"],"sourcesContent":["\u0000asm\u0001\u0000\u0000\u0000\u0001\u0019\u0005`\u0001\u0001`\u0000\u0001`\u0003\u0000`\u0002\u0001`\u0000\u0000\u0003\u0007\u0006\u0001\u0000\u0002\u0003\u0000\u0004\u0005\u0003\u0001\u0000\u0001\u0006\r\u0002\u0001A\u0000\u000b\u0001A\u0001\u000b\u0007c\u0007\ninit_graph\u0000\u0000\u000bcreate_node\u0000\u0001\u000eadd_dependency\u0000\u0002\tpropagate\u0000\u0003\u0015get_update_buffer_ptr\u0000\u0004\u0006_start\u0000\u0005\u0006memory\u0002\u0000\f\u0001\u0001\n¶\u0004\u00062\u0001\u0001#\u0001A\bk$\u0001#\u0000\"\u0000AÂ\u0000j$\u0000#\u0001A\bj$\u0001 \u0000A\u00006\u0002A \u0000A\u00006\u0002B \u0000\u000b\u0017\u0000 \u0000 \u0000(\u0002A\"\u0000A\u0001j6\u0002A \u0000\u000bf\u0001\u0002 \u0000 \u0002A\u0002lj(\u0002\u0002\"\u0003A\u0000J\"\u0004\u0004 \u0000 \u0002A\u0002lj \u0003A\u0001kA\u0002tj(\u0002\u0000 \u0001F\u0005 \u0004\u000bE\u0004@ \u0000 \u0002A\u0002lj\"\u0000 \u0003A\u0002tj(\u0002\u0000 \u00016\u0002\u0000 \u0000(\u0002\u0002\"\u0000 \u0000(\u0002\u0000A\u0001j6\u0002\u0000\u000b\u000bí\u0002\u0002\u0001~\u0007 \u0000A\u00006\u0002B#\u0001A\u0001k\"\u0003A\u0000A\u0004ü\u000b\u0000 \u0003A\u0004jA\u0000A\u0001ü\u000b\u0000 \u0000 \u0001A\u0002lj(\u0002\u0002!\u0007\u0003@ \u0002 \u0007¬S\u0004@ \u0003A\u0004j \u0004A\u0002tj \u0000 \u0001A\u0002lj \u0002§A\u0002tj(\u0002\u0000\"\u00056\u0002\u0000 \u0004A\u0001j!\u0004 \u0003 \u0005A\u0005uA\u0002tj\"\u0006 \u0006(\u0002\u0000A\u0001 \u0005tr6\u0002\u0000 \u0002B\u0001|!\u0002\f\u0001\u000b\u000b\u0003@ \u0004 \bJ\u0004@ \u0003A\u0004j \bA\u0002tj(\u0002\u0000!\u0001 \bA\u0001j!\b \u0000A\u0002t \u0000jAÉ\u0002j \u00016\u0002\u0000 \u0000 \u0000(\u0002BA\u0001j6\u0002B \u0000 \u0001A\u0002lj(\u0002\u0002!\u0007B\u0000!\u0002\u0003@ \u0002 \u0007¬S\u0004@ \u0003 \u0000 \u0001A\u0002lj \u0002§A\u0002tj(\u0002\u0000\"\u0005A\u0005u\"\u0006A\u0002tj(\u0002\u0000A\u0001 \u0005t\"\tqE\u0004@ \u0003 \u0006A\u0002tj\"\u0006 \u0006(\u0002\u0000 \tr6\u0002\u0000 \u0003A\u0004j \u0004A\u0002tj \u00056\u0002\u0000 \u0004A\u0001j!\u0004\u000b \u0002B\u0001|!\u0002\f\u0001\u000b\u000b\f\u0001\u000b\u000b \u0000(\u0002B\u000b\n\u0000 \u0000AÁ\u0000j\u000b\b\u0000A\u0001$\u0000\u000b\u000bû\u0005\u0001\u0000A\u0001\u000bò\u0005malloc(n <= 0)valloc(n <= 0)string.+: malloc failed/home/poteto/.local/src/v/vlib/builtin/wasm/string.v:43:7: s[i]index out of range/home/poteto/.local/src/v/vlib/builtin/wasm/string.v:43:19: other[i]/home/poteto/.local/src/v/vlib/builtin/wasm/string.v:55:25: s[i]/home/poteto/.local/src/v/vlib/builtin/wasm/string.v:55:36: other[i]/home/poteto/.local/src/v/vlib/builtin/wasm/string.v:57:14: s[i]/home/poteto/.local/src/v/vlib/builtin/wasm/string.v:57:25: other[i]string index out of range\nV panic: 000102030405060708090011121314151617181910212223242526272829203132333435363738393041424344454647484940515253545556575859506162636465666768696071727374757677787970818283848586878889809192939495969798999\u0004F\u0000\u0000È\u0000\u0000\u0000-9223372036854775808truefalsetos(): nil string","/**\n * V-Signal: Ultra-minimal reactive state management\n * Inspired by Jotai's simplicity, powered by V WASM\n */\n\n// @rollup/plugin-wasm will inline this as base64\nimport initVsignal from \"./vsignal.wasm\";\n\n// === Types ===\ntype Getter = <T>(atom: VAtom<T>) => T;\ntype Setter = <T>(atom: VAtom<T>, value: T | ((prev: T) => T)) => void;\ntype Subscriber = () => void;\ntype DependencySet = Set<VAtom<any>>;\n\nexport interface VAtom<T> {\n  _brand: \"v-atom\";\n  init: T;\n  read?: (get: Getter) => T;\n  // WASM integration\n  id?: number;\n  // Optimization: Direct state access\n  _state?: VAtomState<T>;\n}\n\ninterface VAtomState<T> {\n  value: T;\n  subscribers: Set<Subscriber>;\n  deps: Set<VAtom<any>>;\n  dependents: Set<VAtom<any>>; // atoms that depend on this atom\n}\n\n// === Render Context ===\nlet currentComponent: (() => void) | null = null;\nlet currentDeps: DependencySet | null = null;\nconst componentDeps = new WeakMap<Subscriber, DependencySet>();\nconst componentCleanups = new WeakMap<Subscriber, Set<() => void>>();\nconst componentContexts = new WeakMap<Subscriber, Record<symbol, any> | null>();\nconst componentChildren = new WeakMap<Subscriber, Set<Subscriber>>();\n\n// === Context ===\nlet globalContext: Record<symbol, any> | null = null;\n\nexport function getContext(id: symbol): any {\n  return globalContext ? globalContext[id as any] : undefined;\n}\n\nexport function runWithContext<T>(context: Record<symbol, any> | null, fn: () => T): T {\n  const prev = globalContext;\n  globalContext = context;\n  try {\n    return fn();\n  } finally {\n    globalContext = prev;\n  }\n}\n\nexport function getGlobalContext() {\n  return globalContext;\n}\n\n// === Batching ===\nconst pendingSubscribers = new Set<Subscriber>();\nlet flushPending = false;\nlet batchDepth = 0;\n// Pre-allocated array to avoid creating new arrays in flush\nlet flushBuffer: Subscriber[] = [];\n\nfunction flush() {\n  flushPending = false;\n  const size = pendingSubscribers.size;\n  // Reuse buffer if capacity is sufficient\n  if (flushBuffer.length < size) {\n    flushBuffer = new Array(size);\n  }\n  // Copy to array for stable iteration\n  let i = 0;\n  for (const sub of pendingSubscribers) {\n    flushBuffer[i++] = sub;\n  }\n  pendingSubscribers.clear();\n  // Execute subscribers\n  for (let j = 0; j < i; j++) {\n    withRenderContext(flushBuffer[j]);\n  }\n}\n\nfunction scheduleUpdates(subscribers: Set<Subscriber>) {\n  subscribers.forEach(pendingSubscribers.add, pendingSubscribers);\n  if (batchDepth > 0) return;\n  if (!flushPending) {\n    flushPending = true;\n    queueMicrotask(flush);\n  }\n}\n\n\nfunction scheduleTransition(cb: () => void): void {\n  const g = globalThis as any;\n  if (typeof g.requestIdleCallback === \"function\") {\n    g.requestIdleCallback(() => cb());\n  } else {\n    setTimeout(cb, 0);\n  }\n}\n\n// === Store (Global State Container) ===\n// Optimization A: Removed WeakMap, state is on atom._state\n\n// === WASM Integration ===\n\ninterface VWasmExports {\n  init_graph: () => number; // returns pointer\n  create_node: (g: number) => number;\n  add_dependency: (g: number, dependent: number, dependency: number) => void;\n  propagate: (g: number, source: number) => number; // returns count\n  get_update_buffer_ptr: (g: number) => number; // returns pointer\n  _start: () => void;\n  memory: WebAssembly.Memory;\n}\n\nlet wasmExports: VWasmExports | null = null;\nlet graphPtr: number = 0;\nlet updateBufferPtr: number = 0; // Optimization C: Cache buffer pointer\nlet cachedUpdateBuffer: Int32Array | null = null;\nconst UPDATE_BUFFER_SIZE = 4096;\n\ntype InitWasmPhase = \"fetch\" | \"compile\" | \"setup\";\nexport interface InitWasmOptions {\n  wasmPath?: string;\n  // Skip network fetch when the module is precompiled/bundled\n  module?: WebAssembly.Module | Promise<WebAssembly.Module>;\n  // Optional perf hook for profiling startup\n  onPerf?: (phase: InitWasmPhase, durationMs: number) => void;\n}\n\nlet wasmInitPromise: Promise<void> | null = null;\n\nexport async function initWasm(\n  options?: string | InitWasmOptions,\n): Promise<void> {\n  if (wasmExports) return;\n  if (wasmInitPromise) return wasmInitPromise;\n\n  const opts: InitWasmOptions =\n    typeof options === \"string\" ? { wasmPath: options } : options || {};\n  const now =\n    typeof performance !== \"undefined\" && typeof performance.now === \"function\"\n      ? () => performance.now()\n      : () => Date.now();\n  const measure = <T>(\n    phase: InitWasmPhase,\n    run: () => Promise<T>,\n  ): Promise<T> => {\n    if (!opts.onPerf) return run();\n    const start = now();\n    return run().then((result) => {\n      opts.onPerf!(phase, now() - start);\n      return result;\n    });\n  };\n\n  const imports = {\n    wasi_snapshot_preview1: {\n      fd_write: (\n        _fd: number,\n        _iovs: number,\n        _iovs_len: number,\n        _nwritten: number,\n      ) => 0,\n      proc_exit: (_code: number) => {},\n    },\n  };\n\n  wasmInitPromise = (async () => {\n    let succeeded = false;\n    try {\n      let instantiated:\n        | WebAssembly.WebAssemblyInstantiatedSource\n        | WebAssembly.Instance\n        | null = null;\n\n      if (opts.module) {\n        // Option 1: Pre-compiled module provided\n        const module = await opts.module;\n        instantiated = await measure(\"compile\", () =>\n          WebAssembly.instantiate(module, imports),\n        );\n      } else if (opts.wasmPath) {\n        // Option 2: Custom WASM path provided (legacy/override)\n        const response = await measure(\"fetch\", () => fetch(opts.wasmPath!));\n\n        if (!response.ok) {\n          console.error(\n            `Failed to load WASM: ${response.status} ${response.statusText}`,\n          );\n          return;\n        }\n\n        if (typeof WebAssembly.instantiateStreaming === \"function\") {\n          try {\n            instantiated = await measure(\"compile\", () =>\n              WebAssembly.instantiateStreaming(response.clone(), imports),\n            );\n          } catch {\n            // Some servers do not return the correct MIME type; fall through to arrayBuffer\n          }\n        }\n\n        if (!instantiated) {\n          const bytes = await response.arrayBuffer();\n          instantiated = await measure(\"compile\", () =>\n            WebAssembly.instantiate(bytes, imports),\n          );\n        }\n      } else {\n        // Option 3: Use bundled WASM via @rollup/plugin-wasm (default)\n        const instance = await measure(\"compile\", () => initVsignal(imports));\n        instantiated = instance;\n      }\n\n      if (!instantiated) {\n        return;\n      }\n\n      const exports =\n        \"instance\" in instantiated\n          ? instantiated.instance.exports\n          : instantiated.exports;\n      wasmExports = exports as unknown as VWasmExports;\n\n      await measure(\"setup\", async () => {\n        // Initialize graph in WASM\n        // Calculate required memory: Graph struct (~1MB) + Safety Margin (~1MB) = 2MB total\n        const GRAPH_SIZE = 1024 * 1024;\n        const SAFETY_MARGIN = 1024 * 1024;\n        const REQUIRED_BYTES = GRAPH_SIZE + SAFETY_MARGIN;\n        const PAGE_SIZE = 65536;\n\n        const currentBytes = wasmExports!.memory.buffer.byteLength;\n        const neededPages = Math.ceil(\n          (REQUIRED_BYTES - currentBytes) / PAGE_SIZE,\n        );\n\n        if (neededPages > 0) {\n          try {\n            wasmExports!.memory.grow(neededPages);\n          } catch {\n            // Ignore if memory is already large enough or fixed\n          }\n        }\n\n        graphPtr = wasmExports!.init_graph();\n        updateBufferPtr = wasmExports!.get_update_buffer_ptr(graphPtr);\n        cachedUpdateBuffer = new Int32Array(\n          wasmExports!.memory.buffer,\n          updateBufferPtr,\n          UPDATE_BUFFER_SIZE,\n        );\n      });\n      succeeded = true;\n    } catch (error) {\n      wasmExports = null;\n      wasmInitPromise = null;\n    } finally {\n      if (!succeeded) {\n        wasmInitPromise = null;\n      }\n    }\n  })();\n\n  return wasmInitPromise!;\n}\n\n// Optimization B: Array for ID lookup\nconst idToAtomArray: VAtom<any>[] = [];\n\n// Optimized getter for derived atom evaluation (no subscription tracking)\nconst fastGet: Getter = (a) =>\n  a._state ? a._state.value : getAtomState(a).value;\n\n/**\n * Ultra-fast getter for use ONLY in WASM propagation path.\n * Assumes atom state is already initialized (guaranteed by WASM graph).\n * Skips the existence check for maximum performance in hot path.\n * DO NOT use outside of updateDerivedWasm function.\n */\nconst ultraFastGet: Getter = (a) => a._state!.value;\n\nfunction trackSubscriber<T>(state: VAtomState<T>, atom: VAtom<T>): void {\n  if (currentComponent) {\n    state.subscribers.add(currentComponent);\n    if (currentDeps) {\n      currentDeps.add(atom);\n    }\n  }\n}\n\nfunction cleanupComponent(component: Subscriber): void {\n  // 1. Cleanup children (effects created inside)\n  const children = componentChildren.get(component);\n  if (children) {\n    for (const child of children) {\n      cleanupComponent(child); // Recursive cleanup\n    }\n    componentChildren.delete(component);\n  }\n\n  // 2. Run cleanups (onCleanup hooks)\n  const cleanups = componentCleanups.get(component);\n  if (cleanups) {\n    for (const cleanup of cleanups) cleanup();\n    componentCleanups.delete(component);\n  }\n\n  // 3. Unsubscribe from dependencies\n  const deps = componentDeps.get(component);\n  if (!deps) return;\n\n  // for-of is faster than forEach\n  for (const atom of deps) {\n    const st = atom._state;\n    if (st) {\n      st.subscribers.delete(component);\n    }\n  }\n\n  componentDeps.delete(component);\n  pendingSubscribers.delete(component);\n}\n\n// Helper to interact with WASM graph\nfunction registerNodeInWasm(atom: VAtom<any>) {\n  if (wasmExports && typeof atom.id === \"undefined\") {\n    atom.id = wasmExports.create_node(graphPtr);\n    idToAtomArray[atom.id] = atom;\n  }\n}\n\nfunction registerDependencyInWasm(\n  dependent: VAtom<any>,\n  dependency: VAtom<any>,\n) {\n  if (\n    wasmExports &&\n    typeof dependent.id === \"number\" &&\n    typeof dependency.id === \"number\"\n  ) {\n    wasmExports.add_dependency(graphPtr, dependent.id, dependency.id);\n  }\n}\n\nfunction getAtomState<T>(atom: VAtom<T>): VAtomState<T> {\n  // Optimization A: Direct property access\n  if (atom._state) return atom._state;\n\n  const deps = new Set<VAtom<any>>();\n  const trackedGet: Getter = (a) => {\n    deps.add(a);\n    // Direct recursive access\n    if (a._state) return a._state.value;\n    return getAtomState(a).value;\n  };\n\n  // Lazy registration for WASM\n  registerNodeInWasm(atom);\n\n  const initial = atom.read ? atom.read(trackedGet) : atom.init;\n\n  const state: VAtomState<T> = {\n    value: initial,\n    subscribers: new Set(),\n    deps,\n    dependents: new Set(),\n  };\n  atom._state = state;\n\n  // Register this atom as a dependent of its dependencies\n  for (const dep of deps) {\n    getAtomState(dep).dependents.add(atom);\n    // WASM Dependency Registration\n    registerNodeInWasm(dep);\n    registerDependencyInWasm(atom, dep);\n  }\n\n  return state;\n}\n\n// === Core API ===\n\nexport function v<T>(initial: T): VAtom<T> {\n  const atom: VAtom<T> = {\n    _brand: \"v-atom\",\n    init: initial,\n  };\n  return atom;\n}\n\nexport function derive<T>(read: (get: Getter) => T): VAtom<T> {\n  const atom: VAtom<T> = {\n    _brand: \"v-atom\",\n    init: undefined as T,\n    read,\n  };\n  return atom;\n}\n\nv.from = derive;\n\n// === Store Operations ===\n\nexport function get<T>(atom: VAtom<T>): T {\n  const state = getAtomState(atom);\n  trackSubscriber(state, atom);\n  return state.value;\n}\n\nexport function set<T>(atom: VAtom<T>, value: T | ((prev: T) => T)): void {\n  const state = getAtomState(atom);\n  const newValue =\n    typeof value === \"function\"\n      ? (value as (prev: T) => T)(state.value)\n      : value;\n\n  // Performance contract: skip propagation/notifications on same-value updates\n  if (!Object.is(state.value, newValue)) {\n    state.value = newValue;\n\n    // Use WASM for propagation if available\n    if (wasmExports && typeof atom.id === \"number\") {\n      updateDerivedWasm(atom);\n    } else {\n      updateDerived(atom);\n    }\n\n    // Notify direct subscribers\n    scheduleUpdates(state.subscribers);\n  }\n}\n\nexport function batch<T>(fn: () => T): T {\n  batchDepth++;\n  try {\n    return fn();\n  } finally {\n    batchDepth--;\n    if (batchDepth === 0 && pendingSubscribers.size > 0 && !flushPending) {\n      flushPending = true;\n      queueMicrotask(flush);\n    }\n  }\n}\n\n\n\nexport function startTransition<T>(fn: () => T): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    scheduleTransition(() => {\n      try {\n        resolve(batch(fn));\n      } catch (error) {\n        reject(error);\n      }\n    });\n  });\n}\n\nexport function subscribe<T>(atom: VAtom<T>, callback: Subscriber): () => void {\n  const state = getAtomState(atom);\n  state.subscribers.add(callback);\n  return () => state.subscribers.delete(callback);\n}\n\n// === Derived Atom Updates (JS Fallback) ===\nfunction updateDerived(source: VAtom<any>): void {\n  const sourceState = getAtomState(source);\n  const visited = new Set<VAtom<any>>();\n  // Array.from is more efficient than spread for Set\n  const queue = Array.from(sourceState.dependents);\n\n  let i = 0;\n  while (i < queue.length) {\n    const atom = queue[i++];\n    if (visited.has(atom)) continue;\n    visited.add(atom);\n\n    if (atom.read) {\n      const state = getAtomState(atom);\n      const newValue = atom.read((a) => getAtomState(a).value);\n\n      if (!Object.is(state.value, newValue)) {\n        state.value = newValue;\n        scheduleUpdates(state.subscribers);\n        // for-of faster than forEach\n        for (const dep of state.dependents) {\n          queue.push(dep);\n        }\n      }\n    }\n  }\n}\n\n// === Derived Atom Updates (WASM) ===\n\nfunction updateDerivedWasm(source: VAtom<any>): void {\n  if (!wasmExports || typeof source.id !== \"number\") return;\n\n  const count = wasmExports.propagate(graphPtr, source.id);\n  if (count > 0) {\n    // Optimization C: Use cached pointer\n    if (\n      !cachedUpdateBuffer ||\n      cachedUpdateBuffer.buffer !== wasmExports.memory.buffer\n    ) {\n      cachedUpdateBuffer = new Int32Array(\n        wasmExports.memory.buffer,\n        updateBufferPtr,\n        UPDATE_BUFFER_SIZE,\n      );\n    }\n\n    for (let i = 0; i < count; i++) {\n      const id = cachedUpdateBuffer[i];\n      // Optimization B: Array access\n      const atom = idToAtomArray[id];\n      if (atom && atom.read) {\n        // Optimization A: Direct access\n        const state = atom._state!;\n\n        // Re-evaluate with ultraFastGet since all atoms in WASM path are initialized\n        const newValue = atom.read(ultraFastGet);\n\n        if (!Object.is(state.value, newValue)) {\n          state.value = newValue;\n          scheduleUpdates(state.subscribers);\n        }\n      }\n    }\n  }\n}\n\n// === Hook for TSX ===\ntype UseAtomResult<T> = [T, (value: T | ((prev: T) => T)) => void];\n\nexport function use<T>(atom: VAtom<T>): UseAtomResult<T> {\n  const state = getAtomState(atom);\n  trackSubscriber(state, atom);\n  return [state.value, (value) => set(atom, value)];\n}\n\nexport function useValue<T>(atom: VAtom<T>): T {\n  return use(atom)[0];\n}\n\nexport function useSet<T>(\n  atom: VAtom<T>,\n): (value: T | ((prev: T) => T)) => void {\n  return use(atom)[1];\n}\n\nexport function withRenderContext(component: () => void): void {\n  // Link to parent if exists (Lifecycle management)\n  if (currentComponent) {\n    let children = componentChildren.get(currentComponent);\n    if (!children) {\n      children = new Set();\n      componentChildren.set(currentComponent, children);\n    }\n    children.add(component);\n  }\n\n  cleanupComponent(component);\n  const deps: DependencySet = new Set();\n  componentDeps.set(component, deps);\n\n  // Capture context if new subscriber\n  if (!componentContexts.has(component)) {\n    componentContexts.set(component, globalContext);\n  }\n  const ctx = componentContexts.get(component) || null;\n\n  const prevComponent = currentComponent;\n  const prevDeps = currentDeps;\n  const prevContext = globalContext;\n\n  currentComponent = component;\n  currentDeps = deps;\n  globalContext = ctx;\n\n  try {\n    component();\n  } catch (err: any) {\n    // 1. Check for Suspense (Promise)\n    if (err && typeof err.then === \"function\") {\n      const suspenseContext =\n        globalContext && globalContext[Symbol.for(\"vitrio.suspense\") as any];\n      if (suspenseContext) {\n        suspenseContext.increment();\n        err.then(\n          () => suspenseContext.decrement(),\n          () => suspenseContext.decrement(),\n        );\n        return; // Suppress error\n      }\n    }\n\n    // 2. Check for Error Boundary\n    const errorContext =\n      globalContext && globalContext[Symbol.for(\"vitrio.error\") as any];\n    if (errorContext) {\n      errorContext.handleError(err);\n      return; // Suppress error\n    }\n\n    // 3. Uncaught\n    throw err;\n  } finally {\n    currentComponent = prevComponent;\n    currentDeps = prevDeps;\n    globalContext = prevContext;\n  }\n}\n\nexport function untrack<T>(fn: () => T): T {\n  const prev = currentComponent;\n  currentComponent = null;\n  try {\n    return fn();\n  } finally {\n    currentComponent = prev;\n  }\n}\n\nexport function onCleanup(fn: () => void): void {\n  if (currentComponent) {\n    let cleanups = componentCleanups.get(currentComponent);\n    if (!cleanups) {\n      cleanups = new Set();\n      componentCleanups.set(currentComponent, cleanups);\n    }\n    cleanups.add(fn);\n  }\n}\n\nexport function createEffect(fn: () => void | (() => void)): void {\n  const effect = () => {\n    const cleanup = fn();\n    if (typeof cleanup === \"function\") {\n      onCleanup(cleanup);\n    }\n  };\n  withRenderContext(effect);\n}\n\nexport function createRoot<T>(fn: (dispose: () => void) => T): T {\n  const owner: Subscriber = () => {}; // Dummy owner\n  const dispose = () => disposeEffect(owner);\n\n  const prev = currentComponent;\n  currentComponent = owner;\n  try {\n    return fn(dispose);\n  } finally {\n    currentComponent = prev;\n  }\n}\n\n// Backwards compatibility/Exports for future use\nexport function wasm() {\n  return wasmExports;\n}\n\nexport function disposeEffect(component: Subscriber): void {\n  cleanupComponent(component);\n}\n","/**\n * V-Signal JSX Runtime\n * Standard JSX runtime exports for react-jsx transform\n */\n\nimport { disposeEffect, withRenderContext } from \"./core\";\n\nexport type ComponentDescriptor = {\n  _brand: \"component\";\n  type: Component;\n  props: Props;\n};\n\nexport type ServerElement = {\n  _brand: \"server-element\";\n  type: string;\n  props: Props;\n  children: Child[];\n};\n\nexport type VNode = Element | Text | DocumentFragment | ComponentDescriptor | ServerElement;\n\n// Child types that can appear in JSX\nexport type Child =\n  | VNode\n  | string\n  | number\n  | boolean\n  | null\n  | undefined\n  | (() => string | number | VNode);\nexport type Children = Child | Child[];\n\nexport type Props = Record<string, any> & {\n  children?: Children;\n};\n\ntype Component = (props: Props) => VNode;\n\nconst CLEANUP_SYMBOL = Symbol(\"v-cleanup\");\n\ntype CleanupFn = () => void;\n\nexport function registerCleanup(node: Node, cleanup: CleanupFn): void {\n  const existing = (node as any)[CLEANUP_SYMBOL] as CleanupFn[] | undefined;\n  if (existing) {\n    existing.push(cleanup);\n  } else {\n    (node as any)[CLEANUP_SYMBOL] = [cleanup];\n  }\n}\n\nexport function cleanupNode(node: Node): void {\n  // Stack-based iteration to avoid recursion overhead\n  const stack: Node[] = [node];\n  while (stack.length > 0) {\n    const current = stack.pop()!;\n    const cleanups = (current as any)[CLEANUP_SYMBOL] as\n      | CleanupFn[]\n      | undefined;\n    if (cleanups) {\n      // Direct loop for better performance\n      const len = cleanups.length;\n      for (let i = 0; i < len; i++) cleanups[i]();\n      (current as any)[CLEANUP_SYMBOL] = undefined;\n    }\n    if (current instanceof Element || current instanceof DocumentFragment) {\n      const children = current.childNodes;\n      // Push children directly to stack\n      const childLen = children.length;\n      for (let i = 0; i < childLen; i++) stack.push(children[i]);\n    }\n  }\n}\n\n/**\n * JSX Factory function (jsx/jsxs for react-jsx transform)\n */\nexport function jsx(\n  type: string | Component,\n  props: Props | null,\n  _key?: string,\n): VNode {\n  return createElement(type, props);\n}\n\nexport const jsxs = jsx;\nexport const jsxDEV = jsx;\n\n/**\n * JSX Factory function (h for classic mode)\n */\nexport function h(\n  type: string | Component,\n  props: Props | null,\n  ...children: any[]\n): VNode {\n  const flat: any[] = [];\n  for (const child of children) {\n    if (Array.isArray(child)) {\n      for (const nested of child) {\n        flat.push(nested);\n      }\n    } else {\n      flat.push(child);\n    }\n  }\n  return createElement(type, { ...props, children: flat });\n}\n\nfunction createElement(type: string | Component, props: Props | null): VNode {\n  // Extract children from props\n  const allChildren = props?.children\n    ? Array.isArray(props.children)\n      ? props.children\n      : [props.children]\n    : [];\n\n  // Handle function components: Return Descriptor (Lazy Evaluation)\n  if (typeof type === \"function\") {\n    return {\n      _brand: \"component\",\n      type,\n      props: { ...props, children: allChildren }\n    };\n  }\n\n  // Server Side Rendering Support\n  if (typeof document === \"undefined\") {\n    return {\n      _brand: \"server-element\",\n      type: type as string,\n      props: props || {},\n      children: allChildren\n    };\n  }\n\n  // Create element (Immediate Evaluation for Host Elements)\n  const el = document.createElement(type);\n\n  // Apply props with reactive binding support\n  if (props) {\n    // Optimization: Use Object.keys for faster iteration\n    const keys = Object.keys(props);\n    for (let i = 0, len = keys.length; i < len; i++) {\n      const key = keys[i];\n      if (key === \"children\") continue;\n\n      const value = props[key];\n\n      if (key.startsWith(\"on\")) {\n        // Event handlers: onClick -> click\n        const event = key.slice(2).toLowerCase();\n        el.addEventListener(event, value);\n      } else if (key === \"ref\") {\n        if (typeof value === \"function\") {\n          value(el);\n        } else if (value && typeof value === \"object\" && \"current\" in value) {\n          value.current = el;\n        }\n      } else if (typeof value === \"function\") {\n        // Reactive binding - subscribe to changes\n        const updateProp = () => {\n          const result = value();\n          if (key === \"class\" || key === \"className\") {\n            el.className = String(result ?? \"\");\n          } else if (key === \"style\") {\n            if (typeof result === \"object\" && result !== null) {\n              // Reset and apply new styles\n              el.removeAttribute(\"style\");\n              Object.assign(el.style, result);\n            } else {\n              el.setAttribute(\"style\", String(result ?? \"\"));\n            }\n          } else {\n            // Generic attribute\n            if (result == null || result === false) {\n              el.removeAttribute(key);\n            } else if (result === true) {\n              el.setAttribute(key, \"\");\n            } else {\n              el.setAttribute(key, String(result));\n            }\n          }\n        };\n        withRenderContext(updateProp);\n        registerCleanup(el, () => disposeEffect(updateProp));\n      } else if (key === \"class\" || key === \"className\") {\n        el.className = value;\n      } else if (key === \"style\" && typeof value === \"object\") {\n        Object.assign(el.style, value);\n      } else if (key === \"style\") {\n        el.style.cssText = String(value ?? \"\");\n      } else if (key === \"id\") {\n        el.id = String(value);\n      } else if (key === \"value\") {\n        (el as HTMLInputElement).value = String(value ?? \"\");\n      } else if (key === \"type\") {\n        (el as HTMLInputElement).type = String(value);\n      } else if (key === \"placeholder\") {\n        (el as HTMLInputElement).placeholder = String(value);\n      } else if (key === \"checked\") {\n        (el as HTMLInputElement).checked = Boolean(value);\n      } else if (key === \"disabled\") {\n        (el as HTMLInputElement).disabled = Boolean(value);\n      } else {\n        el.setAttribute(key, String(value));\n      }\n    }\n  }\n\n  // Append children\n  appendChildren(el, allChildren);\n\n  return el;\n}\n\nexport function resolve(child: any): Node | null {\n  if (child == null || child === false || child === true) return null;\n\n  // In SSR (no DOM), `Node` is undefined.\n  if (typeof Node !== \"undefined\" && child instanceof Node) return child;\n\n  if (Array.isArray(child)) {\n    const frag = document.createDocumentFragment();\n    for (const c of child) {\n      const resolved = resolve(c);\n      if (resolved) frag.appendChild(resolved);\n    }\n    return frag;\n  }\n\n  // Component Descriptor -> Execute\n  if (typeof child === 'object' && child._brand === 'component') {\n    const res = child.type(child.props);\n    return resolve(res);\n  }\n\n  // Reactive Function (Text Binding or Dynamic Component)\n  if (typeof child === 'function') {\n    const marker = document.createComment(\"t\");\n    let currentNodes: Node[] = [];\n\n    const update = () => {\n      const result = child();\n      const newNode = resolve(result);\n\n      // Normalize to array for consistent handling\n      let newNodes: Node[] = [];\n      if (newNode instanceof DocumentFragment) {\n        newNodes = Array.from(newNode.childNodes);\n      } else if (newNode) {\n        newNodes = [newNode];\n      }\n\n      const parent = marker.parentNode;\n\n      if (!parent) {\n        // Initial run: just capture nodes\n        currentNodes = newNodes;\n      } else {\n        // Update run: replace old nodes with new nodes\n\n        // Remove old nodes\n        for (const n of currentNodes) {\n           cleanupNode(n);\n           if (n.parentNode === parent) parent.removeChild(n);\n        }\n\n        // Insert new nodes\n        let prev = marker;\n        for (const n of newNodes) {\n           parent.insertBefore(n, prev.nextSibling);\n           prev = n;\n        }\n        currentNodes = newNodes;\n      }\n    };\n\n    withRenderContext(update);\n    registerCleanup(marker, () => disposeEffect(update));\n\n    // Return Fragment containing marker and initial nodes\n    const frag = document.createDocumentFragment();\n    frag.appendChild(marker);\n    for (const n of currentNodes) {\n      frag.appendChild(n);\n    }\n    return frag as unknown as Node; // Casting to Node to satisfy return type, though Fragment is a Node\n  }\n\n  // String/Number\n  return document.createTextNode(String(child));\n}\n\nfunction appendChildren(parent: Element, children: any[]): void {\n  for (const child of children) {\n    const resolved = resolve(child);\n    if (resolved) {\n      parent.appendChild(resolved);\n    }\n  }\n}\n\n/**\n * Fragment support\n */\nexport function Fragment(props: { children?: any[] }): DocumentFragment | any[] {\n  if (typeof document === \"undefined\") {\n    return props.children || [];\n  }\n  const frag = document.createDocumentFragment();\n  if (props.children) {\n    appendChildren(\n      frag as any,\n      Array.isArray(props.children) ? props.children : [props.children],\n    );\n  }\n  return frag;\n}\n\n// JSX namespace for TypeScript - Vitrio uses VNode which includes DocumentFragment\ndeclare global {\n  namespace JSX {\n    // Allow any HTML element\n    interface IntrinsicElements {\n      [elemName: string]: any;\n    }\n    // VNode includes Element, Text, and DocumentFragment\n    type Element = import(\"./jsx-runtime\").VNode;\n    interface ElementChildrenAttribute {\n      children: {};\n    }\n  }\n}\n\nexport namespace JSX {\n  export interface IntrinsicElements {\n    [elemName: string]: any;\n  }\n  export type Element = VNode;\n  export interface ElementChildrenAttribute {\n    children: {};\n  }\n}\n"],"mappings":"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"}