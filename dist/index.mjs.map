{"version":3,"file":"index.mjs","names":["i","prevNode","newKeySet","v","v"],"sources":["../src/store.ts","../src/context.ts","../src/flow.ts","../src/router.ts","../src/resource.ts","../src/boundary.ts","../src/render.ts","../src/form.ts"],"sourcesContent":["import { v, get, set, type VAtom } from './core';\n\nconst nodeCache = new WeakMap<object, Map<string | symbol, VAtom<any>>>();\nconst proxyCache = new WeakMap<object, object>();\n\nfunction getAtom(target: object, prop: string | symbol, value: any): VAtom<any> {\n  let nodes = nodeCache.get(target);\n  if (!nodes) {\n    nodes = new Map();\n    nodeCache.set(target, nodes);\n  }\n  let atom = nodes.get(prop);\n  if (!atom) {\n    atom = v(value);\n    nodes.set(prop, atom);\n  }\n  return atom;\n}\n\nfunction wrap<T extends object>(obj: T): T {\n  if (proxyCache.has(obj)) return proxyCache.get(obj) as T;\n\n  const proxy = new Proxy(obj, {\n    get(target, prop, receiver) {\n      const value = Reflect.get(target, prop, receiver);\n      // Skip tracking for symbols/iterators to avoid weird loops or framework internals\n      if (typeof prop === 'symbol') return value;\n\n      // Track dependency\n      const atom = getAtom(target, prop, value);\n      get(atom); // Subscribe\n\n      if (value != null && typeof value === 'object') {\n        return wrap(value);\n      }\n      return value;\n    },\n    set(target, prop, newValue, receiver) {\n      const current = Reflect.get(target, prop, receiver);\n      if (current !== newValue) {\n        Reflect.set(target, prop, newValue, receiver);\n        const atom = getAtom(target, prop, newValue);\n        set(atom, newValue);\n      }\n      return true;\n    },\n    deleteProperty(target, prop) {\n      const success = Reflect.deleteProperty(target, prop);\n      if (success) {\n         // Notify subscribers of this property that it's gone (undefined)\n         const atom = getAtom(target, prop, undefined);\n         set(atom, undefined);\n      }\n      return success;\n    }\n  });\n\n  proxyCache.set(obj, proxy);\n  return proxy;\n}\n\nexport type SetStoreFunction<T> = (fn: (state: T) => void) => void;\n\nexport function createStore<T extends object>(initialState: T): [T, SetStoreFunction<T>] {\n  const state = wrap(initialState);\n\n  const setState = (fn: (state: T) => void) => {\n    // Vitrio batches updates automatically via core microtask\n    fn(state);\n  };\n\n  return [state, setState];\n}\n","import { getContext, runWithContext, getGlobalContext } from \"./core\";\nimport { resolve } from \"./jsx-runtime\";\n\nexport interface Context<T> {\n  id: symbol;\n  defaultValue: T;\n  Provider: (props: { value: T; children: any }) => any;\n}\n\nexport function createContext<T>(defaultValue: T, key?: symbol): Context<T> {\n  const id = key || Symbol(\"context\");\n\n  const Provider = (props: { value: T; children: any }) => {\n    // Create new context inheriting from current\n    const current = getGlobalContext();\n    // Use Object.create for prototype chain lookup\n    const newContext = Object.create(current || null);\n    newContext[id] = props.value;\n\n    return runWithContext(newContext, () => {\n      // Resolve children while context is active.\n      // In SSR, resolve() is DOM-free and just normalizes/executes descriptors.\n      return resolve(props.children);\n    });\n  };\n\n  return { id, defaultValue, Provider };\n}\n\nexport function useContext<T>(context: Context<T>): T {\n  const value = getContext(context.id);\n  if (value === undefined) {\n    return context.defaultValue;\n  }\n  return value as T;\n}\n","/**\n * V-Signal Control Flow Components\n * Solid-style Show/For/Switch with marker-based DOM updates\n */\n\nimport { cleanupNode, registerCleanup, resolve, type VNode } from \"./jsx-runtime\";\nimport { disposeEffect, withRenderContext } from \"./core\";\n\ntype MaybeReactive<T> = T | (() => T);\n\nfunction resolveValue<T>(value: MaybeReactive<T>): T {\n  return typeof value === \"function\" ? (value as () => T)() : value;\n}\n\n/**\n * Conditional rendering with marker nodes\n * @example\n * <Show when={isVisible}>\n *   <Content />\n * </Show>\n */\nexport function Show(props: {\n  when: MaybeReactive<boolean>;\n  children: VNode | (() => VNode) | (VNode | (() => VNode))[];\n  fallback?: VNode | (() => VNode) | (VNode | (() => VNode))[];\n}): VNode {\n  const marker = document.createComment(\"show\");\n  // Track list of nodes (support Fragments)\n  let currentNodes: Node[] = [];\n  let showingFallback = false;\n\n  // Extract first child (JSX passes as array)\n  const getChild = () => {\n    const c = Array.isArray(props.children)\n      ? props.children[0]\n      : props.children;\n    return typeof c === 'function' ? resolve(c()) : resolve(c);\n  };\n  const getFallback = () => {\n    if (!props.fallback) return null;\n    const f = Array.isArray(props.fallback)\n      ? props.fallback[0]\n      : props.fallback;\n    return typeof f === 'function' ? resolve(f()) : resolve(f);\n  };\n\n  const update = () => {\n    const condition = resolveValue(props.when);\n    const parent = marker.parentNode;\n    if (!parent) return;\n\n    if (condition) {\n      // Show main content\n      if (showingFallback && currentNodes.length > 0) {\n        for (const n of currentNodes) {\n           cleanupNode(n);\n           n.parentNode?.removeChild(n);\n        }\n        currentNodes = [];\n      }\n\n      if (currentNodes.length === 0 || showingFallback) {\n        const child = getChild();\n        if (child) {\n          if (child instanceof DocumentFragment) {\n            currentNodes = Array.from(child.childNodes);\n            parent.insertBefore(child, marker.nextSibling);\n          } else if (child instanceof Node) {\n            currentNodes = [child];\n            parent.insertBefore(child, marker.nextSibling);\n          }\n        }\n        showingFallback = false;\n      }\n    } else {\n      // Show fallback or nothing\n      if (currentNodes.length > 0 && !showingFallback) {\n        for (const n of currentNodes) {\n           cleanupNode(n);\n           n.parentNode?.removeChild(n);\n        }\n        currentNodes = [];\n      }\n\n      if (props.fallback && !showingFallback) {\n        const fallback = getFallback();\n        if (fallback) {\n          if (fallback instanceof DocumentFragment) {\n             currentNodes = Array.from(fallback.childNodes);\n             parent.insertBefore(fallback, marker.nextSibling);\n          } else if (fallback instanceof Node) {\n             currentNodes = [fallback];\n             parent.insertBefore(fallback, marker.nextSibling);\n          }\n          showingFallback = true;\n        }\n      } else if (!props.fallback) {\n        showingFallback = false;\n      }\n    }\n  };\n\n  // Create fragment container\n  const frag = document.createDocumentFragment();\n  frag.appendChild(marker);\n\n  registerCleanup(marker, () => disposeEffect(update));\n\n  // Initial render with subscription\n  withRenderContext(update);\n\n  return frag as unknown as VNode;\n}\n\n/**\n * List rendering with keyed reconciliation\n * @example\n * <For each={items}>\n *   {(item, index) => <li>{item.name}</li>}\n * </For>\n */\nexport function For<T>(props: {\n  each: MaybeReactive<T[]>;\n  children:\n    | ((item: T, index: () => number) => VNode)\n    | ((item: T, index: () => number) => VNode)[];\n  key?: (item: T, index: number) => string | number;\n}): VNode {\n  const marker = document.createComment(\"for\");\n  type Key = string | number;\n  type ForEntry = {\n    node: Node;\n    item: T;\n    index: number;\n    indexFn: () => number;\n    indexRef: { value: number };\n  };\n\n  const nodeMap = new Map<Key, ForEntry>();\n  let currentKeys: Key[] = [];\n\n  // Default key function uses index\n  const getKey = props.key || ((_item: T, i: number) => i);\n\n  // Extract render function from children (JSX passes as array)\n  const renderFn = Array.isArray(props.children)\n    ? props.children[0]\n    : props.children;\n\n  // Create fragment container first\n  const frag = document.createDocumentFragment();\n  frag.appendChild(marker);\n\n  const update = () => {\n    const items = resolveValue(props.each);\n    const targetParent: Node = marker.parentNode || frag;\n    const len = items.length;\n    const prevLen = currentKeys.length;\n\n    // Fast path: empty to empty (no-op)\n    if (len === 0 && prevLen === 0) return;\n\n    // Pre-allocate array with exact size\n    const newKeys: Key[] = new Array(len);\n    // Inline key generation for speed\n    let i = 0;\n    while (i < len) {\n      newKeys[i] = getKey(items[i], i);\n      i++;\n    }\n\n    // Fast path: pure append when prefix is unchanged\n    if (prevLen > 0 && len >= prevLen) {\n      let isPrefix = true;\n      for (let i = 0; i < prevLen; i++) {\n        if (currentKeys[i] !== newKeys[i]) {\n          isPrefix = false;\n          break;\n        }\n      }\n\n      if (isPrefix) {\n        let prevNode = prevLen\n          ? nodeMap.get(currentKeys[prevLen - 1])?.node || marker\n          : marker;\n\n        for (let i = prevLen; i < len; i++) {\n          const key = newKeys[i];\n          const indexRef = { value: i };\n          const indexFn = () => indexRef.value;\n          const descriptor = renderFn(items[i], indexFn);\n          const node = resolve(descriptor);\n\n          if (node instanceof Node) {\n            const entry: ForEntry = {\n              node,\n              item: items[i],\n              index: i,\n              indexFn,\n              indexRef,\n            };\n            nodeMap.set(key, entry);\n            targetParent.insertBefore(node, prevNode.nextSibling);\n            prevNode = node;\n          }\n        }\n\n        currentKeys = newKeys;\n        return;\n      }\n    }\n\n    // Fast path: shrink only (no reorders), keep stable order while removing missing nodes\n    if (prevLen > 0 && len <= prevLen) {\n      let nextIdx = 0;\n      for (let i = 0; i < prevLen && nextIdx < len; i++) {\n        if (currentKeys[i] === newKeys[nextIdx]) {\n          nextIdx++;\n        }\n      }\n\n      if (nextIdx === len) {\n        const newKeySet = new Set(newKeys);\n        for (const oldKey of currentKeys) {\n          if (!newKeySet.has(oldKey)) {\n            const entry = nodeMap.get(oldKey);\n            if (entry) {\n              cleanupNode(entry.node);\n              entry.node.parentNode?.removeChild(entry.node);\n              nodeMap.delete(oldKey);\n            }\n          }\n        }\n\n        let prevNode: Node = marker;\n        for (let i = 0; i < len; i++) {\n          const key = newKeys[i];\n          const entry = nodeMap.get(key);\n          if (entry) {\n            entry.index = i;\n            entry.indexRef.value = i;\n            if (prevNode.nextSibling !== entry.node) {\n              targetParent.insertBefore(entry.node, prevNode.nextSibling);\n            }\n            prevNode = entry.node;\n          }\n        }\n\n        currentKeys = newKeys;\n        return;\n      }\n    }\n\n    const newKeySet = new Set(newKeys);\n\n    // Remove nodes that no longer exist\n    for (const oldKey of currentKeys) {\n      if (!newKeySet.has(oldKey)) {\n        const entry = nodeMap.get(oldKey);\n        if (entry) {\n          cleanupNode(entry.node);\n          entry.node.parentNode?.removeChild(entry.node);\n          nodeMap.delete(oldKey);\n        }\n      }\n    }\n\n    // Insert/reorder nodes (iterate in order)\n    let prevNode: Node = marker;\n    for (let i = 0; i < len; i++) {\n      const item = items[i];\n      const key = newKeys[i];\n\n      let entry = nodeMap.get(key);\n      if (!entry) {\n        const indexRef = { value: i };\n        const indexFn = () => indexRef.value;\n        const descriptor = renderFn(item, indexFn);\n        const node = resolve(descriptor);\n\n        if (node instanceof Node) {\n          entry = { node, item, index: i, indexFn, indexRef };\n          nodeMap.set(key, entry);\n          targetParent.insertBefore(node, prevNode.nextSibling);\n        }\n      } else {\n        entry.item = item;\n        entry.index = i;\n        entry.indexRef.value = i;\n\n        if (prevNode.nextSibling !== entry.node) {\n          targetParent.insertBefore(entry.node, prevNode.nextSibling);\n        }\n      }\n\n      if (entry) {\n        prevNode = entry.node;\n      }\n    }\n\n    currentKeys = newKeys;\n  };\n\n  registerCleanup(marker, () => disposeEffect(update));\n\n  // Initial render with subscription\n  withRenderContext(update);\n\n  return frag as unknown as VNode;\n}\n\n/**\n * Switch/Match for reactive pattern matching\n * @example\n * <Switch fallback={<Default />}>\n *   <Match when={() => status() === 'loading'}><Spinner /></Match>\n *   <Match when={() => status() === 'error'}><Error /></Match>\n * </Switch>\n */\n\n// Internal type for Match children passed to Switch\ninterface MatchChild {\n  _isMatch: true;\n  when: MaybeReactive<boolean>;\n  children: VNode | (() => VNode);\n}\n\nexport function Switch(props: {\n  fallback?: VNode | (() => VNode);\n  children: (MatchChild | VNode)[];\n}): VNode {\n  const marker = document.createComment(\"switch\");\n  // Track current nodes (support Fragments)\n  let currentNodes: Node[] = [];\n  let currentIndex: number = -1; // -1 means fallback\n\n  const getFallback = () => {\n    if (!props.fallback) return null;\n    return typeof props.fallback === \"function\"\n      ? resolve(props.fallback())\n      : resolve(props.fallback);\n  };\n\n  const update = () => {\n    const parent = marker.parentNode;\n    if (!parent) return;\n\n    // Find first matching child\n    let newIndex = -1;\n    let matchedChildDescriptor: VNode | null = null;\n\n    const children = Array.isArray(props.children)\n      ? props.children\n      : [props.children];\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      let resolvedChild: any = child;\n      if (child && typeof child === 'object' && (child as any)._brand === 'component') {\n         const descriptor = child as any;\n         resolvedChild = descriptor.type(descriptor.props);\n      }\n\n      if (\n        resolvedChild &&\n        typeof resolvedChild === \"object\" &&\n        \"_isMatch\" in resolvedChild &&\n        (resolvedChild as MatchChild)._isMatch\n      ) {\n        const matchChild = resolvedChild as MatchChild;\n        const condition = resolveValue(matchChild.when);\n        if (condition) {\n          newIndex = i;\n          const c = matchChild.children;\n          matchedChildDescriptor = typeof c === \"function\" ? c() : c;\n          break;\n        }\n      }\n    }\n\n    // Only update DOM if the matched index changed\n    if (newIndex !== currentIndex) {\n      // Remove current nodes\n      if (currentNodes.length > 0) {\n        for (const n of currentNodes) {\n          cleanupNode(n);\n          n.parentNode?.removeChild(n);\n        }\n        currentNodes = [];\n      }\n\n      currentIndex = newIndex;\n\n      let nextNode: Node | null | DocumentFragment = null;\n\n      if (matchedChildDescriptor) {\n        nextNode = resolve(matchedChildDescriptor);\n      } else if (newIndex === -1) {\n        // Show fallback\n        nextNode = getFallback();\n      }\n\n      if (nextNode) {\n         if (nextNode instanceof DocumentFragment) {\n            currentNodes = Array.from(nextNode.childNodes);\n            parent.insertBefore(nextNode, marker.nextSibling);\n         } else if (nextNode instanceof Node) {\n            currentNodes = [nextNode];\n            parent.insertBefore(nextNode, marker.nextSibling);\n         }\n      }\n    }\n  };\n\n  const frag = document.createDocumentFragment();\n  frag.appendChild(marker);\n\n  registerCleanup(marker, () => disposeEffect(update));\n\n  // Initial render with subscription\n  withRenderContext(update);\n\n  return frag as unknown as VNode;\n}\n\nexport function Match(props: {\n  when: MaybeReactive<boolean>;\n  children: VNode | (() => VNode);\n}): MatchChild {\n  // Return a special object that Switch can recognize\n  return {\n    _isMatch: true,\n    when: props.when,\n    children: props.children,\n  } as unknown as MatchChild;\n}\n","import {\n  v,\n  get,\n  set,\n  onCleanup,\n  type VAtom,\n  type Getter,\n} from \"./core\";\nimport { Show } from \"./flow\";\nimport { h, resolve } from \"./jsx-runtime\";\nimport { createContext, useContext } from \"./context\";\n\nexport interface LocationState {\n  /** Path relative to `basename` */\n  path: string;\n  query: string;\n  hash: string;\n}\n\nexport interface LoaderCtx {\n  params: Record<string, string>;\n  search: URLSearchParams;\n  location: LocationState;\n}\n\nexport type RouteLoader<T> = (ctx: LoaderCtx) => T | Promise<T>;\nexport type RouteAction<Input = any, Output = any> = (\n  ctx: LoaderCtx,\n  input: Input,\n) => Output | Promise<Output>;\n\n// --- Location ---\n\nconst basenameAtom: VAtom<string> = v(\"\");\n\nfunction stripBasename(pathname: string, basename: string): string {\n  if (!basename) return pathname;\n  const b = basename.endsWith(\"/\") ? basename.slice(0, -1) : basename;\n  if (b && pathname.startsWith(b)) {\n    const rest = pathname.slice(b.length);\n    return rest.startsWith(\"/\") ? rest : \"/\" + rest;\n  }\n  return pathname;\n}\n\nfunction withBasename(pathname: string, basename: string): string {\n  if (!basename) return pathname;\n  const b = basename.endsWith(\"/\") ? basename.slice(0, -1) : basename;\n  if (!b) return pathname;\n  if (pathname === \"/\") return b + \"/\";\n  return b + (pathname.startsWith(\"/\") ? pathname : \"/\" + pathname);\n}\n\nconst getWindowLocation = (basename = \"\"): LocationState => {\n  if (typeof window === \"undefined\") {\n    return { path: \"/\", query: \"\", hash: \"\" };\n  }\n  return {\n    path: stripBasename(window.location.pathname, basename),\n    query: window.location.search,\n    hash: window.location.hash,\n  };\n};\n\nexport const location: VAtom<LocationState> = v(getWindowLocation());\n\nconst LocationAtomContext = createContext<VAtom<LocationState> | null>(null);\nconst LoaderCacheContext = createContext<Map<string, any> | null>(null);\n\nfunction resolveUrl(to: string): URL {\n  let base =\n    typeof window !== \"undefined\" && window.location\n      ? window.location.href\n      : \"http://localhost/\";\n  if (base === \"about:srcdoc\") base = \"http://localhost/\";\n  return new URL(to, base);\n}\n\nexport function prefetch(to: string): Promise<any> {\n  const url = resolveUrl(to);\n  const base = get(basenameAtom);\n  const path = stripBasename(url.pathname, base);\n  const query = url.search;\n\n  for (const entry of routeRegistry.values()) {\n    const params = matchPath(entry.pattern, path);\n    if (params === null) continue;\n\n    const loc: LocationState = { path, query, hash: url.hash };\n    const ctx: LoaderCtx = { params, search: url.searchParams, location: loc };\n    const key = makeRouteCacheKey(entry.routeId, ctx);\n\n    return primeLoaderCache(key, () => Promise.resolve(entry.loader(ctx))).catch(\n      // Prefetch should never crash the app\n      () => undefined,\n    );\n  }\n\n  return Promise.resolve(undefined);\n}\n\nexport function navigate(to: string) {\n  if (typeof window !== \"undefined\") {\n    const url = resolveUrl(to);\n    const base = get(basenameAtom);\n\n    const relPath = stripBasename(url.pathname, base);\n    const next = withBasename(relPath, base) + url.search + url.hash;\n\n    const nextLoc: LocationState = {\n      path: relPath,\n      query: url.search,\n      hash: url.hash,\n    };\n\n    try {\n      window.history.pushState(null, \"\", next);\n    } catch (e) {\n      // In srcdoc iframe or restricted environments, pushState may fail.\n      // We proceed with updating the app location state anyway (memory routing).\n      console.warn(\"Router: history.pushState blocked\", e);\n    }\n    set(location, nextLoc);\n  }\n}\n\nexport function Router(props: { children: any; basename?: string; locationAtom?: VAtom<LocationState>; loaderCache?: Map<string, any> }) {\n  // Keep basename in an atom so navigate/prefetch can read it.\n  if (typeof props.basename === \"string\") {\n    set(basenameAtom, props.basename);\n    // Update location to ensure it reflects the new basename\n    set(location, getWindowLocation(props.basename));\n  }\n\n  const update = () => set(location, getWindowLocation(get(basenameAtom)));\n  if (typeof window !== \"undefined\") {\n    window.addEventListener(\"popstate\", update);\n    onCleanup(() => window.removeEventListener(\"popstate\", update));\n  }\n  const locAtom = props.locationAtom ?? location;\n  const cache = props.loaderCache ?? loaderCache;\n\n  // Provide per-tree atoms/caches\n  const tree = {\n    // @ts-ignore\n    _brand: \"component\",\n    type: LocationAtomContext.Provider,\n    props: {\n      value: locAtom,\n      children: {\n        // @ts-ignore\n        _brand: \"component\",\n        type: LoaderCacheContext.Provider,\n        props: { value: cache, children: props.children },\n      },\n    },\n  };\n\n  // SSR: do not call resolve() (DOM-oriented)\n  if (typeof document === \"undefined\") return tree as any;\n\n  // Client: resolve into DOM nodes\n  return resolve(tree as any);\n}\n\n/**\n * Exclusive routing: renders the first matching <Route> among its children.\n * Place a `path=\"*\"` route last for 404.\n */\nexport function Routes(props: { children: any }) {\n  return () => {\n    const base = useContext(BasePathContext);\n    const locAtom = useContext(LocationAtomContext) ?? location;\n    const loc = get(locAtom);\n\n    const children = Array.isArray(props.children)\n      ? props.children\n      : [props.children];\n\n    for (const child of children) {\n      if (!child || typeof child !== \"object\") continue;\n      if ((child as any)._brand !== \"component\") continue;\n      const c: any = child;\n      const p = c.props;\n      if (!p || typeof p.path !== \"string\") continue;\n\n      const fullPattern = p.path.startsWith(\"/\")\n        ? p.path\n        : joinPaths(base || \"\", p.path);\n\n      if (matchPath(fullPattern, loc.path) !== null) {\n        return child;\n      }\n    }\n\n    return null;\n  };\n}\n\n// --- Contexts / hooks ---\n\nconst ParamsContext = createContext<Record<string, string>>({});\nconst BasePathContext = createContext<string>(\"\");\nconst SearchContext = createContext<URLSearchParams>(new URLSearchParams());\nconst LoaderDataContext = createContext<any>(undefined);\nconst OutletContext = createContext<any>(null);\n\ntype ActionState = {\n  pending: boolean;\n  error: any;\n  data: any;\n  run?: (input: any) => Promise<any>;\n};\nconst ActionContext = createContext<VAtom<ActionState> | null>(null);\n\nexport function useParams(): Record<string, string> {\n  return useContext(ParamsContext);\n}\n\nexport function useSearch(): URLSearchParams {\n  return useContext(SearchContext);\n}\n\nexport function useLoaderData<T = any>(): T {\n  return useContext(LoaderDataContext) as T;\n}\n\nexport function Outlet() {\n  return useContext(OutletContext);\n}\n\nexport type ActionApi<TInput = any, TOutput = any> = {\n  run: (input: TInput) => Promise<TOutput>;\n  pending: () => boolean;\n  error: () => any;\n  data: () => TOutput | undefined;\n};\n\nexport function useAction<TInput = any, TOutput = any>(): ActionApi<TInput, TOutput> {\n  const stAtom = useContext(ActionContext);\n  if (!stAtom) {\n    return {\n      run: async () => {\n        throw new Error(\"useAction() used outside of a Route with action\");\n      },\n      pending: () => false,\n      error: () => undefined,\n      data: () => undefined,\n    };\n  }\n\n  const run = (input: TInput) => {\n    const st = get(stAtom);\n    if (!st.run) {\n      return Promise.reject(new Error(\"No action registered for this route\"));\n    }\n    return st.run(input) as Promise<TOutput>;\n  };\n\n  return {\n    run,\n    pending: () => get(stAtom).pending,\n    error: () => get(stAtom).error,\n    data: () => get(stAtom).data as TOutput | undefined,\n  };\n}\n\n// --- Loader cache (SPA) ---\n\nexport type CacheEntry =\n  | { status: \"pending\"; promise: Promise<any> }\n  | { status: \"fulfilled\"; value: any }\n  | { status: \"rejected\"; error: any };\n\nconst loaderCache = new Map<string, CacheEntry>();\n\n// (internal) loader cache is provided via LoaderCacheContext in Route/invalidations\n\n// --- SSR/CSR hydration helpers ---\nexport function dehydrateLoaderCache(cache?: Map<string, CacheEntry>): Record<string, { status: \"fulfilled\"; value: any } | { status: \"rejected\"; error: any }> {\n  const out: any = {};\n  const c = cache ?? loaderCache;\n  for (const [k, v] of c.entries()) {\n    if (v.status === \"fulfilled\") out[k] = { status: \"fulfilled\", value: v.value };\n    if (v.status === \"rejected\") out[k] = { status: \"rejected\", error: String((v as any).error ?? '') };\n  }\n  return out;\n}\n\nexport function hydrateLoaderCache(data: Record<string, any> | null | undefined, cache?: Map<string, CacheEntry>): void {\n  const c = cache ?? loaderCache;\n  if (!data) return;\n  for (const [k, v] of Object.entries(data)) {\n    if (!v || typeof v !== 'object') continue;\n    if ((v as any).status === 'fulfilled') c.set(k, { status: 'fulfilled', value: (v as any).value });\n    if ((v as any).status === 'rejected') c.set(k, { status: 'rejected', error: new Error(String((v as any).error ?? '')) });\n  }\n}\n\ntype RouteRegistryEntry = {\n  routeId: string;\n  pattern: string;\n  loader: RouteLoader<any>;\n};\n\n// Best-effort registry for prefetch() (populated as routes mount)\nconst routeRegistry = new Map<string, RouteRegistryEntry>();\n\n// A small global tick to trigger route re-evaluation after invalidation.\n// (Deleting from the cache alone does not notify the reactive graph.)\nconst invalidateTick = v(0);\n\nfunction stableJson(obj: any): string {\n  if (!obj || typeof obj !== \"object\") return JSON.stringify(obj);\n  const keys = Object.keys(obj).sort();\n  const out: any = {};\n  for (const k of keys) out[k] = (obj as any)[k];\n  return JSON.stringify(out);\n}\n\nfunction makeRouteCacheKey(routeId: string, ctx: LoaderCtx): string {\n  // Path matters for params; query matters for search-driven loaders.\n  // Params are included explicitly to avoid ambiguity.\n  return `${routeId}|path=${ctx.location.path}|query=${ctx.location.query}|params=${stableJson(ctx.params)}`;\n}\n\nexport function invalidateRoute(routeIdPrefix: string): void {\n  // Global invalidation helper (default cache)\n  for (const k of loaderCache.keys()) {\n    if (k.startsWith(routeIdPrefix + \"|\")) {\n      loaderCache.delete(k);\n    }\n  }\n  set(invalidateTick, (c) => c + 1);\n}\n\n// Back-compat: invalidate(prefix) == invalidateRoute(prefix)\nexport const invalidate = invalidateRoute;\n\nconst RouteKeyContext = createContext<string | null>(null);\n\nexport function invalidateCurrent(): void {\n  const key = useContext(RouteKeyContext);\n  if (!key) return;\n  const cache = useContext(LoaderCacheContext) ?? loaderCache;\n  cache.delete(key);\n  set(invalidateTick, (c) => c + 1);\n}\n\nfunction primeLoaderCache<T>(key: string, load: () => Promise<T>, cache: Map<string, CacheEntry> = loaderCache): Promise<T> {\n  const existing = cache.get(key);\n  if (existing) {\n    if (existing.status === \"fulfilled\") return Promise.resolve(existing.value as T);\n    if (existing.status === \"rejected\") return Promise.reject(existing.error);\n    return existing.promise as Promise<T>;\n  }\n\n  const promise = Promise.resolve().then(load);\n  cache.set(key, { status: \"pending\", promise });\n\n  promise.then(\n    (value) => cache.set(key, { status: \"fulfilled\", value }),\n    (error) => cache.set(key, { status: \"rejected\", error }),\n  );\n\n  return promise;\n}\n\nfunction readLoaderCache<T>(key: string, load: () => Promise<T>, cache: Map<string, CacheEntry> = loaderCache): T {\n  const existing = cache.get(key);\n  if (existing) {\n    if (existing.status === \"fulfilled\") return existing.value as T;\n    if (existing.status === \"rejected\") throw existing.error;\n    throw existing.promise;\n  }\n\n  const promise = primeLoaderCache(key, load, cache);\n  throw promise;\n}\n\n// --- Path matching ---\n\nfunction joinPaths(base: string, child: string): string {\n  const b = base.endsWith(\"/\") ? base.slice(0, -1) : base;\n  const c = child.startsWith(\"/\") ? child : \"/\" + child;\n  if (!b) return c;\n  return b + c;\n}\n\nfunction matchPath(\n  pattern: string,\n  path: string,\n): Record<string, string> | null {\n  if (pattern === \"*\") return {};\n\n  const isPrefix = pattern.endsWith(\"*\");\n  const normalized = isPrefix ? pattern.slice(0, -1) : pattern;\n\n  const a = normalized.split(\"/\").filter(Boolean);\n  const b = path.split(\"/\").filter(Boolean);\n\n  if (!isPrefix && a.length !== b.length) return null;\n  if (isPrefix && b.length < a.length) return null;\n\n  const params: Record<string, string> = {};\n  for (let i = 0; i < a.length; i++) {\n    const seg = a[i];\n    const cur = b[i];\n    if (seg.startsWith(\":\")) {\n      params[seg.slice(1)] = decodeURIComponent(cur);\n      continue;\n    }\n    if (seg !== cur) return null;\n  }\n  return params;\n}\n\n// --- Route component ---\n\nexport function Route<T = any>(props: {\n  id?: string;\n  path: string;\n  loader?: RouteLoader<T>;\n  action?: RouteAction<any, any>;\n  invalidateOnAction?: boolean;\n  children:\n    | any\n    | ((data: T, ctx: LoaderCtx & { action: ActionApi<any, any> }) => any);\n}) {\n  const routeId = props.id || props.path;\n\n  // NOTE: Route must be reactive to both location changes and loader invalidations.\n  // Returning a dynamic function makes the subtree refresh (with cleanup) when deps change.\n  return () => {\n    const base = useContext(BasePathContext);\n    const fullPattern = props.path.startsWith(\"/\")\n      ? props.path\n      : joinPaths(base || \"\", props.path);\n\n    const locAtom = useContext(LocationAtomContext) ?? location;\n    const loc = get(locAtom);\n    const matchedParams = matchPath(fullPattern, loc.path);\n    if (matchedParams === null) return null;\n\n    const parentParams = useContext(ParamsContext);\n    const params = { ...(parentParams || {}), ...(matchedParams || {}) };\n    const search = new URLSearchParams(loc.query || \"\");\n    const ctx: LoaderCtx = { params, search, location: loc };\n\n    // Nested routes can use relative paths. We expose the current matched base.\n    const nextBase = fullPattern.endsWith(\"*\")\n      ? fullPattern.slice(0, -1)\n      : fullPattern;\n\n    let data: any = undefined;\n    let routeCacheKey: string | null = null;\n    if (props.loader) {\n      // subscribe to invalidations\n      get(invalidateTick);\n\n      routeCacheKey = makeRouteCacheKey(routeId, ctx);\n\n      // Register for prefetch() (best-effort)\n      routeRegistry.set(`${routeId}|${fullPattern}`, {\n        routeId,\n        pattern: fullPattern,\n        loader: props.loader,\n      });\n\n      const cache = useContext(LoaderCacheContext) ?? loaderCache;\n      data = readLoaderCache(\n        routeCacheKey,\n        () => Promise.resolve(props.loader!(ctx)),\n        cache,\n      );\n    }\n\n      const actionState = v<ActionState>({\n        pending: false,\n        error: undefined,\n        data: undefined,\n      });\n\n      if (props.action) {\n        const invalidateOnAction = props.invalidateOnAction ?? true;\n        set(actionState, (prev) => ({\n          ...prev,\n          run: async (input: any) => {\n            // IMPORTANT: do not overwrite `run` with a stale/undefined value.\n            // Always preserve the existing function by using an updater.\n            set(actionState, (s) => ({ ...s, pending: true, error: undefined }));\n            try {\n              const out = await props.action!(ctx, input);\n              set(actionState, (s) => ({ ...s, pending: false, data: out }));\n              if (invalidateOnAction && routeCacheKey) {\n                const cache = useContext(LoaderCacheContext) ?? loaderCache;\n                cache.delete(routeCacheKey);\n                set(invalidateTick, (c) => c + 1);\n              }\n              return out;\n            } catch (e) {\n              set(actionState, (s) => ({ ...s, pending: false, error: e }));\n              throw e;\n            }\n          },\n        }));\n      }\n\n      const actionApi: ActionApi<any, any> = {\n        run: (input: any) => {\n          const st = get(actionState);\n          if (!st.run) {\n            return Promise.reject(new Error(\"No action registered for this route\"));\n          }\n          return st.run(input);\n        },\n        pending: () => get(actionState).pending,\n        error: () => get(actionState).error,\n        data: () => get(actionState).data,\n      };\n\n      const childrenArr = Array.isArray(props.children)\n        ? props.children\n        : [props.children];\n\n      const renderChild = childrenArr[0];\n      const nestedCandidates = childrenArr.slice(1);\n\n      const child =\n        typeof renderChild === \"function\"\n          ? () => renderChild(data, { ...ctx, action: actionApi })\n          : renderChild;\n\n      // Implicit nested routing: if nested <Route> children exist, pick the first match\n      // under this route's base and expose it via <Outlet />.\n      let outletNode: any = null;\n      if (nestedCandidates.length > 0) {\n        for (const n of nestedCandidates) {\n          if (!n || typeof n !== \"object\") continue;\n          if ((n as any)._brand !== \"component\") continue;\n          const c: any = n;\n          const p = c.props;\n          if (!p || typeof p.path !== \"string\") continue;\n\n          const fullPattern = p.path.startsWith(\"/\")\n            ? p.path\n            : joinPaths(nextBase || \"\", p.path);\n\n          if (matchPath(fullPattern, loc.path) !== null) {\n            outletNode = n;\n            break;\n          }\n        }\n      }\n\n    // Provide contexts to children\n    const tree = {\n      // @ts-ignore\n      _brand: \"component\",\n      type: ParamsContext.Provider,\n      props: {\n        value: params,\n        children: {\n          // @ts-ignore\n          _brand: \"component\",\n          type: SearchContext.Provider,\n          props: {\n            value: search,\n            children: {\n              // @ts-ignore\n              _brand: \"component\",\n              type: LoaderDataContext.Provider,\n              props: {\n                value: data,\n                children: {\n                  // @ts-ignore\n                  _brand: \"component\",\n                  type: ActionContext.Provider,\n                  props: {\n                    value: actionState,\n                    children: {\n                      // @ts-ignore\n                      _brand: \"component\",\n                      type: RouteKeyContext.Provider,\n                      props: {\n                        value: routeCacheKey,\n                        children: {\n                          // @ts-ignore\n                          _brand: \"component\",\n                          type: BasePathContext.Provider,\n                          props: {\n                            value: nextBase,\n                            children: {\n                              // @ts-ignore\n                              _brand: \"component\",\n                              type: OutletContext.Provider,\n                              props: {\n                                value: outletNode,\n                                children: child,\n                              },\n                            },\n                          },\n                        },\n                      },\n                    },\n                  },\n                },\n              },\n            },\n          },\n        },\n      },\n    };\n\n    // SSR: return the descriptor tree as-is (server renderer will execute/walk it)\n    if (typeof document === \"undefined\") return tree as any;\n\n    // Client: resolve into actual DOM nodes\n    return resolve(tree as any);\n  };\n}\n\nexport function A(props: {\n  href: string;\n  class?: string;\n  className?: string;\n  children?: any;\n}) {\n  const onClick = (e: MouseEvent) => {\n    if (e.ctrlKey || e.metaKey || e.altKey || e.shiftKey || e.button !== 0)\n      return;\n    e.preventDefault();\n    navigate(props.href);\n  };\n\n  const onMouseEnter = () => {\n    // Best-effort prefetch\n    prefetch(props.href);\n  };\n\n  return h(\"a\", { ...props, onClick, onMouseEnter }, props.children);\n}\n","import { v, get, set, createEffect, onCleanup, type VAtom } from \"./core\";\n\nexport interface ResourceState<T> {\n  value?: T;\n  loading: boolean;\n  error?: any;\n}\n\nexport interface Resource<T> {\n  (): T | undefined;\n  loading: () => boolean;\n  error: () => any;\n  refetch: () => void;\n  mutate: (val: T | undefined) => void;\n  state: VAtom<ResourceState<T>>;\n}\n\nexport type ResourceFetcher<S, T> = (\n  source: S,\n  info: { signal: AbortSignal }\n) => Promise<T>;\n\nexport interface ResourceOptions<T> {\n  initialValue?: T;\n  retries?: number;\n  retryDelayMs?: number | ((attempt: number, error: unknown) => number);\n  onError?: (error: unknown, attempt: number) => void;\n}\n\nfunction delay(ms: number, signal: AbortSignal): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => {\n      signal.removeEventListener(\"abort\", onAbort);\n      resolve();\n    }, ms);\n\n    const onAbort = () => {\n      clearTimeout(timer);\n      reject(new DOMException(\"Aborted\", \"AbortError\"));\n    };\n\n    signal.addEventListener(\"abort\", onAbort, { once: true });\n  });\n}\n\nfunction normalizeRetryDelay<T>(\n  options: ResourceOptions<T>,\n  attempt: number,\n  error: unknown,\n): number {\n  if (typeof options.retryDelayMs === \"function\") {\n    return Math.max(0, options.retryDelayMs(attempt, error));\n  }\n  if (typeof options.retryDelayMs === \"number\") {\n    return Math.max(0, options.retryDelayMs);\n  }\n  // default lightweight backoff: 150ms, 300ms, 450ms...\n  return 150 * attempt;\n}\n\nexport function createResource<T>(\n  fetcher: ResourceFetcher<void, T>,\n  options?: ResourceOptions<T>\n): Resource<T>;\nexport function createResource<T, S>(\n  source: S | (() => S),\n  fetcher: ResourceFetcher<S, T>,\n  options?: ResourceOptions<T>\n): Resource<T>;\nexport function createResource<T, S = void>(\n  source: S | (() => S) | ResourceFetcher<void, T>,\n  fetcherOrOptions?: ResourceFetcher<S, T> | ResourceOptions<T>,\n  maybeOptions?: ResourceOptions<T>\n): Resource<T> {\n  let srcFn: () => S;\n  let fn: ResourceFetcher<S, T>;\n  let options: ResourceOptions<T> = maybeOptions || {};\n\n  if (arguments.length === 1) {\n    fn = source as unknown as ResourceFetcher<S, T>;\n    srcFn = () => undefined as unknown as S;\n  } else if (arguments.length === 2 && typeof fetcherOrOptions !== \"function\") {\n    fn = source as unknown as ResourceFetcher<S, T>;\n    srcFn = () => undefined as unknown as S;\n    options = (fetcherOrOptions || {}) as ResourceOptions<T>;\n  } else {\n    fn = fetcherOrOptions as ResourceFetcher<S, T>;\n    if (typeof source === \"function\") {\n      srcFn = source as () => S;\n    } else {\n      srcFn = () => source as S;\n    }\n  }\n\n  const retries = Math.max(0, options.retries ?? 0);\n\n  const state = v<ResourceState<T>>({\n    value: options.initialValue,\n    loading: true,\n    error: undefined\n  });\n\n  let abortController: AbortController | null = null;\n  let currentPromise: Promise<T> | null = null;\n\n  const load = async (currentSource: S) => {\n    if (abortController) abortController.abort();\n    abortController = new AbortController();\n    const signal = abortController.signal;\n\n    set(state, (prev) => ({ ...prev, loading: true, error: undefined }));\n\n    const execute = async (): Promise<T> => {\n      let attempt = 0;\n      while (true) {\n        attempt += 1;\n        try {\n          return await fn(currentSource, { signal });\n        } catch (error) {\n          if (signal.aborted) throw error;\n          options.onError?.(error, attempt);\n\n          if (attempt > retries) {\n            throw error;\n          }\n\n          const waitMs = normalizeRetryDelay(options, attempt, error);\n          if (waitMs > 0) {\n            await delay(waitMs, signal);\n          }\n        }\n      }\n    };\n\n    try {\n      const p = execute();\n      currentPromise = p;\n      const result = await p;\n\n      if (signal.aborted) return;\n\n      set(state, {\n        value: result,\n        loading: false,\n        error: undefined\n      });\n    } catch (err: any) {\n      if (signal.aborted) return;\n      set(state, (prev) => ({\n        ...prev,\n        loading: false,\n        error: err\n      }));\n    }\n  };\n\n  createEffect(() => {\n    const s = srcFn();\n    load(s);\n  });\n\n  onCleanup(() => {\n    if (abortController) abortController.abort();\n  });\n\n  const read = () => {\n    const s = get(state);\n    if (s.error) throw s.error;\n    if (s.loading && currentPromise) {\n      throw currentPromise;\n    }\n    return s.value;\n  };\n\n  read.loading = () => get(state).loading;\n  read.error = () => get(state).error;\n  read.refetch = () => load(srcFn());\n  read.mutate = (val: T | undefined) =>\n    set(state, { value: val, loading: false, error: undefined });\n  read.state = state;\n\n  return read as Resource<T>;\n}\n","import { v, get, set, type VAtom } from './core';\nimport { createContext } from './context';\nimport { resolve, type VNode } from './jsx-runtime';\n\n// Define context symbols\nexport const SUSPENSE_CONTEXT_SYMBOL = Symbol.for(\"vitrio.suspense\");\nexport const ERROR_BOUNDARY_CONTEXT_SYMBOL = Symbol.for(\"vitrio.error\");\n\n// --- Suspense ---\n\nexport interface SuspenseContextValue {\n  increment: () => void;\n  decrement: () => void;\n  state: VAtom<number>;\n}\n\nexport const SuspenseContext = createContext<SuspenseContextValue | undefined>(undefined, SUSPENSE_CONTEXT_SYMBOL);\n\nexport function Suspense(props: { fallback?: any; children: any }): VNode {\n  const pendingCount = v(0);\n\n  const contextValue: SuspenseContextValue = {\n    increment: () => set(pendingCount, (c) => c + 1),\n    decrement: () => set(pendingCount, (c) => Math.max(0, c - 1)),\n    state: pendingCount\n  };\n\n  const renderer = () => {\n    const count = get(pendingCount);\n    if (count > 0) {\n      return resolve(props.fallback);\n    }\n\n    try {\n      return resolve(props.children);\n    } catch (err: any) {\n      if (err && typeof err.then === 'function') {\n        // Handle initial render suspension\n        contextValue.increment();\n        err.then(contextValue.decrement, contextValue.decrement);\n        return resolve(props.fallback);\n      }\n      throw err;\n    }\n  };\n\n  return (\n    // @ts-ignore\n    {\n      _brand: \"component\",\n      type: SuspenseContext.Provider,\n      props: {\n        value: contextValue,\n        children: renderer\n      }\n    }\n  );\n}\n\n// --- ErrorBoundary ---\n\nexport interface ErrorBoundaryContextValue {\n  handleError: (error: any) => void;\n}\n\nexport const ErrorBoundaryContext = createContext<ErrorBoundaryContextValue | undefined>(undefined, ERROR_BOUNDARY_CONTEXT_SYMBOL);\n\nexport function ErrorBoundary(props: { fallback: (err: any) => any; children: any }): VNode {\n  const error = v<any>(null);\n\n  const contextValue: ErrorBoundaryContextValue = {\n    handleError: (err: any) => set(error, err)\n  };\n\n  const renderer = () => {\n    const err = get(error);\n    if (err) {\n      const fallbackFn = props.fallback;\n      return resolve(typeof fallbackFn === 'function' ? fallbackFn(err) : fallbackFn);\n    }\n\n    try {\n      return resolve(props.children);\n    } catch (e: any) {\n      // Handle initial render error\n      set(error, e);\n      const fallbackFn = props.fallback;\n      return resolve(typeof fallbackFn === 'function' ? fallbackFn(e) : fallbackFn);\n    }\n  };\n\n  return (\n    // @ts-ignore\n    {\n      _brand: \"component\",\n      type: ErrorBoundaryContext.Provider,\n      props: {\n        value: contextValue,\n        children: renderer\n      }\n    }\n  );\n}\n","/**\n * V-Signal Render\n * Mount components to DOM - Solid-style (create once, update bindings)\n */\n\nimport { cleanupNode, resolve, type VNode } from './jsx-runtime'\nimport { createRoot } from './core'\n\n/**\n * Render a component to a container\n * DOM is created once. Reactive updates happen via fine-grained bindings in jsx-runtime.\n * @example\n * render(<App />, document.getElementById('root'))\n */\nexport function render(component: VNode | (() => VNode), container: Element | null): (() => void) {\n  if (!container) {\n    throw new Error('Container element not found')\n  }\n  \n  // Dispose previous root if exists\n  const oldDispose = (container as any)._dispose;\n  if (typeof oldDispose === 'function') {\n    oldDispose();\n    (container as any)._dispose = undefined;\n  }\n\n  // Clear container once with cleanup to drop subscriptions\n  while (container.firstChild) {\n    cleanupNode(container.firstChild)\n    container.removeChild(container.firstChild)\n  }\n  \n  // Create DOM once - reactive bindings in jsx-runtime handle updates\n  // Run in root scope to manage lifecycle of effects\n  return createRoot((dispose) => {\n    (container as any)._dispose = dispose;\n\n    // If component is a function (e.g. () => <App /> or App), execute it first\n    // to get the VNode/Descriptor.\n    let root = component;\n    if (typeof root === 'function') {\n      root = (root as () => VNode)();\n    }\n\n    const result = resolve(root);\n    if (result) {\n      container.appendChild(result)\n    }\n\n    return dispose;\n  });\n}\n\n/**\n * Mount shorthand\n */\nexport const mount = render\n","import { h } from \"./jsx-runtime\";\nimport type { ActionApi } from \"./router\";\n\nfunction coerceScalar(value: any): any {\n  if (typeof value !== \"string\") return value;\n\n  const s = value.trim();\n  if (s === \"\") return s;\n\n  if (s === \"true\") return true;\n  if (s === \"false\") return false;\n  if (s === \"null\") return null;\n  if (s === \"undefined\") return undefined;\n\n  // number-ish (avoid converting things like \"00123\"? we keep it simple)\n  const n = Number(s);\n  if (!Number.isNaN(n) && String(n) === s) return n;\n\n  return value;\n}\n\nfunction formDataToObject(fd: FormData, coerce: boolean): Record<string, any> {\n  const out: Record<string, any> = {};\n\n  for (const [k, v] of fd.entries()) {\n    const raw = typeof v === \"string\" ? v : v; // File stays as File\n    const value = coerce ? coerceScalar(raw) : raw;\n\n    if (k in out) {\n      const prev = out[k];\n      out[k] = Array.isArray(prev) ? [...prev, value] : [prev, value];\n    } else {\n      out[k] = value;\n    }\n  }\n\n  return out;\n}\n\nexport function Form<TInput = any>(props: {\n  action: ActionApi<TInput, any>;\n  /**\n   * Optional explicit value.\n   * If omitted, the value is collected from <input name=...> via FormData.\n   */\n  value?: TInput | (() => TInput);\n  /**\n   * When collecting from FormData, coerce common scalars:\n   * - \"true\"/\"false\" -> boolean\n   * - numeric strings -> number\n   * - \"null\" -> null\n   * Default: true (ergonomic for small apps)\n   */\n  coerce?: boolean;\n  /** Render action error under the form when true (default: false). */\n  showError?: boolean;\n  children: any;\n  disabled?: boolean;\n}) {\n  const onSubmit = (e: SubmitEvent) => {\n    e.preventDefault();\n\n    let val: any;\n    if (typeof props.value !== \"undefined\") {\n      val = typeof props.value === \"function\" ? (props.value as any)() : props.value;\n    } else {\n      const form = e.currentTarget as HTMLFormElement;\n      const fd = new FormData(form);\n      val = formDataToObject(fd, props.coerce ?? true);\n\n      // Checkbox ergonomics: if a checkbox is unchecked, it does not appear in FormData.\n      // We intentionally keep this as-is for flexibility. Apps can normalize defaults.\n    }\n\n    props.action.run(val);\n  };\n\n  const disabled = props.disabled ?? false;\n\n  const formEl = h(\n    \"form\",\n    {\n      onSubmit,\n      // Disable pointer interactions when pending (best-effort)\n      \"aria-busy\": () => (props.action.pending() ? \"true\" : \"false\"),\n      style: () =>\n        props.action.pending() || disabled\n          ? \"pointer-events:none;opacity:0.7;\"\n          : \"\",\n    },\n    props.children,\n  );\n\n  if (!props.showError) return formEl;\n\n  // Render error under the form when enabled.\n  return h(\n    \"div\",\n    {},\n    formEl,\n    () => {\n      const err = props.action.error();\n      if (!err) return null;\n      const msg = err instanceof Error ? err.stack || err.message : String(err);\n      return h(\n        \"pre\",\n        { style: \"color:#b00020;white-space:pre-wrap;margin:0.5rem 0 0;\" },\n        msg,\n      );\n    },\n  );\n}\n"],"mappings":"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"}