{"version":3,"file":"index.mjs","names":["i","prevNode","newKeySet"],"sources":["../src/store.ts","../src/context.ts","../src/flow.ts","../src/router.ts","../src/resource.ts","../src/boundary.ts","../src/render.ts","../src/form.ts"],"sourcesContent":["import { v, get, set, type VAtom } from './core';\n\nconst nodeCache = new WeakMap<object, Map<string | symbol, VAtom<any>>>();\nconst proxyCache = new WeakMap<object, object>();\n\nfunction getAtom(target: object, prop: string | symbol, value: any): VAtom<any> {\n  let nodes = nodeCache.get(target);\n  if (!nodes) {\n    nodes = new Map();\n    nodeCache.set(target, nodes);\n  }\n  let atom = nodes.get(prop);\n  if (!atom) {\n    atom = v(value);\n    nodes.set(prop, atom);\n  }\n  return atom;\n}\n\nfunction wrap<T extends object>(obj: T): T {\n  if (proxyCache.has(obj)) return proxyCache.get(obj) as T;\n\n  const proxy = new Proxy(obj, {\n    get(target, prop, receiver) {\n      const value = Reflect.get(target, prop, receiver);\n      // Skip tracking for symbols/iterators to avoid weird loops or framework internals\n      if (typeof prop === 'symbol') return value;\n\n      // Track dependency\n      const atom = getAtom(target, prop, value);\n      get(atom); // Subscribe\n\n      if (value != null && typeof value === 'object') {\n        return wrap(value);\n      }\n      return value;\n    },\n    set(target, prop, newValue, receiver) {\n      const current = Reflect.get(target, prop, receiver);\n      if (current !== newValue) {\n        Reflect.set(target, prop, newValue, receiver);\n        const atom = getAtom(target, prop, newValue);\n        set(atom, newValue);\n      }\n      return true;\n    },\n    deleteProperty(target, prop) {\n      const success = Reflect.deleteProperty(target, prop);\n      if (success) {\n         // Notify subscribers of this property that it's gone (undefined)\n         const atom = getAtom(target, prop, undefined);\n         set(atom, undefined);\n      }\n      return success;\n    }\n  });\n\n  proxyCache.set(obj, proxy);\n  return proxy;\n}\n\nexport type SetStoreFunction<T> = (fn: (state: T) => void) => void;\n\nexport function createStore<T extends object>(initialState: T): [T, SetStoreFunction<T>] {\n  const state = wrap(initialState);\n\n  const setState = (fn: (state: T) => void) => {\n    // Vitrio batches updates automatically via core microtask\n    fn(state);\n  };\n\n  return [state, setState];\n}\n","import { getContext, runWithContext, getGlobalContext } from \"./core\";\nimport { resolve } from \"./jsx-runtime\";\n\nexport interface Context<T> {\n  id: symbol;\n  defaultValue: T;\n  Provider: (props: { value: T; children: any }) => any;\n}\n\nexport function createContext<T>(defaultValue: T, key?: symbol): Context<T> {\n  const id = key || Symbol(\"context\");\n\n  const Provider = (props: { value: T; children: any }) => {\n    // Create new context inheriting from current\n    const current = getGlobalContext();\n    // Use Object.create for prototype chain lookup\n    const newContext = Object.create(current || null);\n    newContext[id] = props.value;\n\n    return runWithContext(newContext, () => {\n      // Resolve children while context is active\n      // This allows components passed as children to execute useContext inside their body\n      return resolve(props.children);\n    });\n  };\n\n  return { id, defaultValue, Provider };\n}\n\nexport function useContext<T>(context: Context<T>): T {\n  const value = getContext(context.id);\n  if (value === undefined) {\n    return context.defaultValue;\n  }\n  return value as T;\n}\n","/**\n * V-Signal Control Flow Components\n * Solid-style Show/For/Switch with marker-based DOM updates\n */\n\nimport { cleanupNode, registerCleanup, resolve, type VNode } from \"./jsx-runtime\";\nimport { disposeEffect, withRenderContext } from \"./core\";\n\ntype MaybeReactive<T> = T | (() => T);\n\nfunction resolveValue<T>(value: MaybeReactive<T>): T {\n  return typeof value === \"function\" ? (value as () => T)() : value;\n}\n\n/**\n * Conditional rendering with marker nodes\n * @example\n * <Show when={isVisible}>\n *   <Content />\n * </Show>\n */\nexport function Show(props: {\n  when: MaybeReactive<boolean>;\n  children: VNode | (() => VNode) | (VNode | (() => VNode))[];\n  fallback?: VNode | (() => VNode) | (VNode | (() => VNode))[];\n}): VNode {\n  const marker = document.createComment(\"show\");\n  // Track list of nodes (support Fragments)\n  let currentNodes: Node[] = [];\n  let showingFallback = false;\n\n  // Extract first child (JSX passes as array)\n  const getChild = () => {\n    const c = Array.isArray(props.children)\n      ? props.children[0]\n      : props.children;\n    return typeof c === 'function' ? resolve(c()) : resolve(c);\n  };\n  const getFallback = () => {\n    if (!props.fallback) return null;\n    const f = Array.isArray(props.fallback)\n      ? props.fallback[0]\n      : props.fallback;\n    return typeof f === 'function' ? resolve(f()) : resolve(f);\n  };\n\n  const update = () => {\n    const condition = resolveValue(props.when);\n    const parent = marker.parentNode;\n    if (!parent) return;\n\n    if (condition) {\n      // Show main content\n      if (showingFallback && currentNodes.length > 0) {\n        for (const n of currentNodes) {\n           cleanupNode(n);\n           n.parentNode?.removeChild(n);\n        }\n        currentNodes = [];\n      }\n\n      if (currentNodes.length === 0 || showingFallback) {\n        const child = getChild();\n        if (child) {\n          if (child instanceof DocumentFragment) {\n            currentNodes = Array.from(child.childNodes);\n            parent.insertBefore(child, marker.nextSibling);\n          } else if (child instanceof Node) {\n            currentNodes = [child];\n            parent.insertBefore(child, marker.nextSibling);\n          }\n        }\n        showingFallback = false;\n      }\n    } else {\n      // Show fallback or nothing\n      if (currentNodes.length > 0 && !showingFallback) {\n        for (const n of currentNodes) {\n           cleanupNode(n);\n           n.parentNode?.removeChild(n);\n        }\n        currentNodes = [];\n      }\n\n      if (props.fallback && !showingFallback) {\n        const fallback = getFallback();\n        if (fallback) {\n          if (fallback instanceof DocumentFragment) {\n             currentNodes = Array.from(fallback.childNodes);\n             parent.insertBefore(fallback, marker.nextSibling);\n          } else if (fallback instanceof Node) {\n             currentNodes = [fallback];\n             parent.insertBefore(fallback, marker.nextSibling);\n          }\n          showingFallback = true;\n        }\n      } else if (!props.fallback) {\n        showingFallback = false;\n      }\n    }\n  };\n\n  // Create fragment container\n  const frag = document.createDocumentFragment();\n  frag.appendChild(marker);\n\n  registerCleanup(marker, () => disposeEffect(update));\n\n  // Initial render with subscription\n  withRenderContext(update);\n\n  return frag as unknown as VNode;\n}\n\n/**\n * List rendering with keyed reconciliation\n * @example\n * <For each={items}>\n *   {(item, index) => <li>{item.name}</li>}\n * </For>\n */\nexport function For<T>(props: {\n  each: MaybeReactive<T[]>;\n  children:\n    | ((item: T, index: () => number) => VNode)\n    | ((item: T, index: () => number) => VNode)[];\n  key?: (item: T, index: number) => string | number;\n}): VNode {\n  const marker = document.createComment(\"for\");\n  type Key = string | number;\n  type ForEntry = {\n    node: Node;\n    item: T;\n    index: number;\n    indexFn: () => number;\n    indexRef: { value: number };\n  };\n\n  const nodeMap = new Map<Key, ForEntry>();\n  let currentKeys: Key[] = [];\n\n  // Default key function uses index\n  const getKey = props.key || ((_item: T, i: number) => i);\n\n  // Extract render function from children (JSX passes as array)\n  const renderFn = Array.isArray(props.children)\n    ? props.children[0]\n    : props.children;\n\n  // Create fragment container first\n  const frag = document.createDocumentFragment();\n  frag.appendChild(marker);\n\n  const update = () => {\n    const items = resolveValue(props.each);\n    const targetParent: Node = marker.parentNode || frag;\n    const len = items.length;\n    const prevLen = currentKeys.length;\n\n    // Fast path: empty to empty (no-op)\n    if (len === 0 && prevLen === 0) return;\n\n    // Pre-allocate array with exact size\n    const newKeys: Key[] = new Array(len);\n    // Inline key generation for speed\n    let i = 0;\n    while (i < len) {\n      newKeys[i] = getKey(items[i], i);\n      i++;\n    }\n\n    // Fast path: pure append when prefix is unchanged\n    if (prevLen > 0 && len >= prevLen) {\n      let isPrefix = true;\n      for (let i = 0; i < prevLen; i++) {\n        if (currentKeys[i] !== newKeys[i]) {\n          isPrefix = false;\n          break;\n        }\n      }\n\n      if (isPrefix) {\n        let prevNode = prevLen\n          ? nodeMap.get(currentKeys[prevLen - 1])?.node || marker\n          : marker;\n\n        for (let i = prevLen; i < len; i++) {\n          const key = newKeys[i];\n          const indexRef = { value: i };\n          const indexFn = () => indexRef.value;\n          const descriptor = renderFn(items[i], indexFn);\n          const node = resolve(descriptor);\n\n          if (node instanceof Node) {\n            const entry: ForEntry = {\n              node,\n              item: items[i],\n              index: i,\n              indexFn,\n              indexRef,\n            };\n            nodeMap.set(key, entry);\n            targetParent.insertBefore(node, prevNode.nextSibling);\n            prevNode = node;\n          }\n        }\n\n        currentKeys = newKeys;\n        return;\n      }\n    }\n\n    // Fast path: shrink only (no reorders), keep stable order while removing missing nodes\n    if (prevLen > 0 && len <= prevLen) {\n      let nextIdx = 0;\n      for (let i = 0; i < prevLen && nextIdx < len; i++) {\n        if (currentKeys[i] === newKeys[nextIdx]) {\n          nextIdx++;\n        }\n      }\n\n      if (nextIdx === len) {\n        const newKeySet = new Set(newKeys);\n        for (const oldKey of currentKeys) {\n          if (!newKeySet.has(oldKey)) {\n            const entry = nodeMap.get(oldKey);\n            if (entry) {\n              cleanupNode(entry.node);\n              entry.node.parentNode?.removeChild(entry.node);\n              nodeMap.delete(oldKey);\n            }\n          }\n        }\n\n        let prevNode: Node = marker;\n        for (let i = 0; i < len; i++) {\n          const key = newKeys[i];\n          const entry = nodeMap.get(key);\n          if (entry) {\n            entry.index = i;\n            entry.indexRef.value = i;\n            if (prevNode.nextSibling !== entry.node) {\n              targetParent.insertBefore(entry.node, prevNode.nextSibling);\n            }\n            prevNode = entry.node;\n          }\n        }\n\n        currentKeys = newKeys;\n        return;\n      }\n    }\n\n    const newKeySet = new Set(newKeys);\n\n    // Remove nodes that no longer exist\n    for (const oldKey of currentKeys) {\n      if (!newKeySet.has(oldKey)) {\n        const entry = nodeMap.get(oldKey);\n        if (entry) {\n          cleanupNode(entry.node);\n          entry.node.parentNode?.removeChild(entry.node);\n          nodeMap.delete(oldKey);\n        }\n      }\n    }\n\n    // Insert/reorder nodes (iterate in order)\n    let prevNode: Node = marker;\n    for (let i = 0; i < len; i++) {\n      const item = items[i];\n      const key = newKeys[i];\n\n      let entry = nodeMap.get(key);\n      if (!entry) {\n        const indexRef = { value: i };\n        const indexFn = () => indexRef.value;\n        const descriptor = renderFn(item, indexFn);\n        const node = resolve(descriptor);\n\n        if (node instanceof Node) {\n          entry = { node, item, index: i, indexFn, indexRef };\n          nodeMap.set(key, entry);\n          targetParent.insertBefore(node, prevNode.nextSibling);\n        }\n      } else {\n        entry.item = item;\n        entry.index = i;\n        entry.indexRef.value = i;\n\n        if (prevNode.nextSibling !== entry.node) {\n          targetParent.insertBefore(entry.node, prevNode.nextSibling);\n        }\n      }\n\n      if (entry) {\n        prevNode = entry.node;\n      }\n    }\n\n    currentKeys = newKeys;\n  };\n\n  registerCleanup(marker, () => disposeEffect(update));\n\n  // Initial render with subscription\n  withRenderContext(update);\n\n  return frag as unknown as VNode;\n}\n\n/**\n * Switch/Match for reactive pattern matching\n * @example\n * <Switch fallback={<Default />}>\n *   <Match when={() => status() === 'loading'}><Spinner /></Match>\n *   <Match when={() => status() === 'error'}><Error /></Match>\n * </Switch>\n */\n\n// Internal type for Match children passed to Switch\ninterface MatchChild {\n  _isMatch: true;\n  when: MaybeReactive<boolean>;\n  children: VNode | (() => VNode);\n}\n\nexport function Switch(props: {\n  fallback?: VNode | (() => VNode);\n  children: (MatchChild | VNode)[];\n}): VNode {\n  const marker = document.createComment(\"switch\");\n  // Track current nodes (support Fragments)\n  let currentNodes: Node[] = [];\n  let currentIndex: number = -1; // -1 means fallback\n\n  const getFallback = () => {\n    if (!props.fallback) return null;\n    return typeof props.fallback === \"function\"\n      ? resolve(props.fallback())\n      : resolve(props.fallback);\n  };\n\n  const update = () => {\n    const parent = marker.parentNode;\n    if (!parent) return;\n\n    // Find first matching child\n    let newIndex = -1;\n    let matchedChildDescriptor: VNode | null = null;\n\n    const children = Array.isArray(props.children)\n      ? props.children\n      : [props.children];\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      let resolvedChild: any = child;\n      if (child && typeof child === 'object' && (child as any)._brand === 'component') {\n         const descriptor = child as any;\n         resolvedChild = descriptor.type(descriptor.props);\n      }\n\n      if (\n        resolvedChild &&\n        typeof resolvedChild === \"object\" &&\n        \"_isMatch\" in resolvedChild &&\n        (resolvedChild as MatchChild)._isMatch\n      ) {\n        const matchChild = resolvedChild as MatchChild;\n        const condition = resolveValue(matchChild.when);\n        if (condition) {\n          newIndex = i;\n          const c = matchChild.children;\n          matchedChildDescriptor = typeof c === \"function\" ? c() : c;\n          break;\n        }\n      }\n    }\n\n    // Only update DOM if the matched index changed\n    if (newIndex !== currentIndex) {\n      // Remove current nodes\n      if (currentNodes.length > 0) {\n        for (const n of currentNodes) {\n          cleanupNode(n);\n          n.parentNode?.removeChild(n);\n        }\n        currentNodes = [];\n      }\n\n      currentIndex = newIndex;\n\n      let nextNode: Node | null | DocumentFragment = null;\n\n      if (matchedChildDescriptor) {\n        nextNode = resolve(matchedChildDescriptor);\n      } else if (newIndex === -1) {\n        // Show fallback\n        nextNode = getFallback();\n      }\n\n      if (nextNode) {\n         if (nextNode instanceof DocumentFragment) {\n            currentNodes = Array.from(nextNode.childNodes);\n            parent.insertBefore(nextNode, marker.nextSibling);\n         } else if (nextNode instanceof Node) {\n            currentNodes = [nextNode];\n            parent.insertBefore(nextNode, marker.nextSibling);\n         }\n      }\n    }\n  };\n\n  const frag = document.createDocumentFragment();\n  frag.appendChild(marker);\n\n  registerCleanup(marker, () => disposeEffect(update));\n\n  // Initial render with subscription\n  withRenderContext(update);\n\n  return frag as unknown as VNode;\n}\n\nexport function Match(props: {\n  when: MaybeReactive<boolean>;\n  children: VNode | (() => VNode);\n}): MatchChild {\n  // Return a special object that Switch can recognize\n  return {\n    _isMatch: true,\n    when: props.when,\n    children: props.children,\n  } as unknown as MatchChild;\n}\n","import {\n  v,\n  get,\n  set,\n  onCleanup,\n  type VAtom,\n  type Getter,\n} from \"./core\";\nimport { Show } from \"./flow\";\nimport { h, resolve } from \"./jsx-runtime\";\nimport { createContext, useContext } from \"./context\";\n\nexport interface LocationState {\n  path: string;\n  query: string;\n  hash: string;\n}\n\nexport interface LoaderCtx {\n  params: Record<string, string>;\n  search: URLSearchParams;\n  location: LocationState;\n}\n\nexport type RouteLoader<T> = (ctx: LoaderCtx) => T | Promise<T>;\nexport type RouteAction<Input = any, Output = any> = (\n  ctx: LoaderCtx,\n  input: Input,\n) => Output | Promise<Output>;\n\n// --- Location ---\n\nconst getWindowLocation = (): LocationState => {\n  if (typeof window === \"undefined\") {\n    return { path: \"/\", query: \"\", hash: \"\" };\n  }\n  return {\n    path: window.location.pathname,\n    query: window.location.search,\n    hash: window.location.hash,\n  };\n};\n\nexport const location: VAtom<LocationState> = v(getWindowLocation());\n\nexport function navigate(to: string) {\n  if (typeof window !== \"undefined\") {\n    window.history.pushState(null, \"\", to);\n    set(location, getWindowLocation());\n  }\n}\n\nexport function Router(props: { children: any }) {\n  const update = () => set(location, getWindowLocation());\n  if (typeof window !== \"undefined\") {\n    window.addEventListener(\"popstate\", update);\n    onCleanup(() => window.removeEventListener(\"popstate\", update));\n  }\n  return props.children;\n}\n\n// --- Contexts / hooks ---\n\nconst ParamsContext = createContext<Record<string, string>>({});\nconst SearchContext = createContext<URLSearchParams>(new URLSearchParams());\nconst LoaderDataContext = createContext<any>(undefined);\n\ntype ActionState = {\n  pending: boolean;\n  error: any;\n  data: any;\n  run?: (input: any) => Promise<any>;\n};\nconst ActionContext = createContext<VAtom<ActionState> | null>(null);\n\nexport function useParams(): Record<string, string> {\n  return useContext(ParamsContext);\n}\n\nexport function useSearch(): URLSearchParams {\n  return useContext(SearchContext);\n}\n\nexport function useLoaderData<T = any>(): T {\n  return useContext(LoaderDataContext) as T;\n}\n\nexport type ActionApi<TInput = any, TOutput = any> = {\n  run: (input: TInput) => Promise<TOutput>;\n  pending: () => boolean;\n  error: () => any;\n  data: () => TOutput | undefined;\n};\n\nexport function useAction<TInput = any, TOutput = any>(): ActionApi<TInput, TOutput> {\n  const stAtom = useContext(ActionContext);\n  if (!stAtom) {\n    return {\n      run: async () => {\n        throw new Error(\"useAction() used outside of a Route with action\");\n      },\n      pending: () => false,\n      error: () => undefined,\n      data: () => undefined,\n    };\n  }\n\n  const run = (input: TInput) => {\n    const st = get(stAtom);\n    if (!st.run) {\n      return Promise.reject(new Error(\"No action registered for this route\"));\n    }\n    return st.run(input) as Promise<TOutput>;\n  };\n\n  return {\n    run,\n    pending: () => get(stAtom).pending,\n    error: () => get(stAtom).error,\n    data: () => get(stAtom).data as TOutput | undefined,\n  };\n}\n\n// --- Loader cache (SPA) ---\n\ntype CacheEntry =\n  | { status: \"pending\"; promise: Promise<any> }\n  | { status: \"fulfilled\"; value: any }\n  | { status: \"rejected\"; error: any };\n\nconst loaderCache = new Map<string, CacheEntry>();\n\nexport function invalidate(prefix: string): void {\n  for (const k of loaderCache.keys()) {\n    if (k.startsWith(prefix)) {\n      loaderCache.delete(k);\n    }\n  }\n}\n\nfunction readLoaderCache<T>(key: string, load: () => Promise<T>): T {\n  const existing = loaderCache.get(key);\n  if (existing) {\n    if (existing.status === \"fulfilled\") return existing.value as T;\n    if (existing.status === \"rejected\") throw existing.error;\n    throw existing.promise;\n  }\n\n  const promise = Promise.resolve().then(load);\n  loaderCache.set(key, { status: \"pending\", promise });\n\n  promise.then(\n    (value) => loaderCache.set(key, { status: \"fulfilled\", value }),\n    (error) => loaderCache.set(key, { status: \"rejected\", error }),\n  );\n\n  throw promise;\n}\n\n// --- Path matching ---\n\nfunction matchPath(\n  pattern: string,\n  path: string,\n): Record<string, string> | null {\n  if (pattern === \"*\") return {};\n\n  // Prefix wildcard: \"/foo/*\"\n  if (pattern.endsWith(\"*\")) {\n    const base = pattern.slice(0, -1);\n    if (path.startsWith(base)) return {};\n    return null;\n  }\n\n  const a = pattern.split(\"/\").filter(Boolean);\n  const b = path.split(\"/\").filter(Boolean);\n  if (a.length !== b.length) return null;\n\n  const params: Record<string, string> = {};\n  for (let i = 0; i < a.length; i++) {\n    const seg = a[i];\n    const cur = b[i];\n    if (seg.startsWith(\":\")) {\n      params[seg.slice(1)] = decodeURIComponent(cur);\n      continue;\n    }\n    if (seg !== cur) return null;\n  }\n  return params;\n}\n\n// --- Route component ---\n\nexport function Route<T = any>(props: {\n  id?: string;\n  path: string;\n  loader?: RouteLoader<T>;\n  action?: RouteAction<any, any>;\n  invalidateOnAction?: boolean;\n  children:\n    | any\n    | ((data: T, ctx: LoaderCtx & { action: ActionApi<any, any> }) => any);\n}) {\n  const routeId = props.id || props.path;\n\n  return Show({\n    when: () => {\n      const loc = get(location);\n      return matchPath(props.path, loc.path) !== null;\n    },\n    children: () => {\n      const loc = get(location);\n      const params = matchPath(props.path, loc.path) || {};\n      const search = new URLSearchParams(loc.query || \"\");\n      const ctx: LoaderCtx = { params, search, location: loc };\n\n      let data: any = undefined;\n      if (props.loader) {\n        const key = `${routeId}?${loc.query}|${loc.path}`;\n        data = readLoaderCache(key, () => Promise.resolve(props.loader!(ctx)));\n      }\n\n      const actionState = v<ActionState>({\n        pending: false,\n        error: undefined,\n        data: undefined,\n      });\n\n      if (props.action) {\n        const invalidateOnAction = props.invalidateOnAction ?? true;\n        set(actionState, (prev) => ({\n          ...prev,\n          run: async (input: any) => {\n            set(actionState, { pending: true, error: undefined, data: prev.data, run: prev.run });\n            try {\n              const out = await props.action!(ctx, input);\n              set(actionState, (s) => ({ ...s, pending: false, data: out }));\n              if (invalidateOnAction) {\n                invalidate(routeId);\n              }\n              return out;\n            } catch (e) {\n              set(actionState, (s) => ({ ...s, pending: false, error: e }));\n              throw e;\n            }\n          },\n        }));\n      }\n\n      const actionApi = useAction();\n\n      const child =\n        typeof props.children === \"function\"\n          ? props.children(data, { ...ctx, action: actionApi })\n          : props.children;\n\n      // Provide contexts to children\n      return resolve({\n        // @ts-ignore\n        _brand: \"component\",\n        type: ParamsContext.Provider,\n        props: {\n          value: params,\n          children: {\n            // @ts-ignore\n            _brand: \"component\",\n            type: SearchContext.Provider,\n            props: {\n              value: search,\n              children: {\n                // @ts-ignore\n                _brand: \"component\",\n                type: LoaderDataContext.Provider,\n                props: {\n                  value: data,\n                  children: {\n                    // @ts-ignore\n                    _brand: \"component\",\n                    type: ActionContext.Provider,\n                    props: {\n                      value: actionState,\n                      children: child,\n                    },\n                  },\n                },\n              },\n            },\n          },\n        },\n      });\n    },\n  });\n}\n\nexport function A(props: {\n  href: string;\n  class?: string;\n  className?: string;\n  children?: any;\n}) {\n  const onClick = (e: MouseEvent) => {\n    if (e.ctrlKey || e.metaKey || e.altKey || e.shiftKey || e.button !== 0)\n      return;\n    e.preventDefault();\n    navigate(props.href);\n  };\n\n  return h(\"a\", { ...props, onClick }, props.children);\n}\n","import { v, get, set, createEffect, onCleanup, type VAtom } from \"./core\";\n\nexport interface ResourceState<T> {\n  value?: T;\n  loading: boolean;\n  error?: any;\n}\n\nexport interface Resource<T> {\n  (): T | undefined;\n  loading: () => boolean;\n  error: () => any;\n  refetch: () => void;\n  mutate: (val: T | undefined) => void;\n  state: VAtom<ResourceState<T>>;\n}\n\nexport type ResourceFetcher<S, T> = (\n  source: S,\n  info: { signal: AbortSignal }\n) => Promise<T>;\n\nexport interface ResourceOptions<T> {\n  initialValue?: T;\n  retries?: number;\n  retryDelayMs?: number | ((attempt: number, error: unknown) => number);\n  onError?: (error: unknown, attempt: number) => void;\n}\n\nfunction delay(ms: number, signal: AbortSignal): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => {\n      signal.removeEventListener(\"abort\", onAbort);\n      resolve();\n    }, ms);\n\n    const onAbort = () => {\n      clearTimeout(timer);\n      reject(new DOMException(\"Aborted\", \"AbortError\"));\n    };\n\n    signal.addEventListener(\"abort\", onAbort, { once: true });\n  });\n}\n\nfunction normalizeRetryDelay<T>(\n  options: ResourceOptions<T>,\n  attempt: number,\n  error: unknown,\n): number {\n  if (typeof options.retryDelayMs === \"function\") {\n    return Math.max(0, options.retryDelayMs(attempt, error));\n  }\n  if (typeof options.retryDelayMs === \"number\") {\n    return Math.max(0, options.retryDelayMs);\n  }\n  // default lightweight backoff: 150ms, 300ms, 450ms...\n  return 150 * attempt;\n}\n\nexport function createResource<T>(\n  fetcher: ResourceFetcher<void, T>,\n  options?: ResourceOptions<T>\n): Resource<T>;\nexport function createResource<T, S>(\n  source: S | (() => S),\n  fetcher: ResourceFetcher<S, T>,\n  options?: ResourceOptions<T>\n): Resource<T>;\nexport function createResource<T, S = void>(\n  source: S | (() => S) | ResourceFetcher<void, T>,\n  fetcherOrOptions?: ResourceFetcher<S, T> | ResourceOptions<T>,\n  maybeOptions?: ResourceOptions<T>\n): Resource<T> {\n  let srcFn: () => S;\n  let fn: ResourceFetcher<S, T>;\n  let options: ResourceOptions<T> = maybeOptions || {};\n\n  if (arguments.length === 1) {\n    fn = source as unknown as ResourceFetcher<S, T>;\n    srcFn = () => undefined as unknown as S;\n  } else if (arguments.length === 2 && typeof fetcherOrOptions !== \"function\") {\n    fn = source as unknown as ResourceFetcher<S, T>;\n    srcFn = () => undefined as unknown as S;\n    options = (fetcherOrOptions || {}) as ResourceOptions<T>;\n  } else {\n    fn = fetcherOrOptions as ResourceFetcher<S, T>;\n    if (typeof source === \"function\") {\n      srcFn = source as () => S;\n    } else {\n      srcFn = () => source as S;\n    }\n  }\n\n  const retries = Math.max(0, options.retries ?? 0);\n\n  const state = v<ResourceState<T>>({\n    value: options.initialValue,\n    loading: true,\n    error: undefined\n  });\n\n  let abortController: AbortController | null = null;\n  let currentPromise: Promise<T> | null = null;\n\n  const load = async (currentSource: S) => {\n    if (abortController) abortController.abort();\n    abortController = new AbortController();\n    const signal = abortController.signal;\n\n    set(state, (prev) => ({ ...prev, loading: true, error: undefined }));\n\n    const execute = async (): Promise<T> => {\n      let attempt = 0;\n      while (true) {\n        attempt += 1;\n        try {\n          return await fn(currentSource, { signal });\n        } catch (error) {\n          if (signal.aborted) throw error;\n          options.onError?.(error, attempt);\n\n          if (attempt > retries) {\n            throw error;\n          }\n\n          const waitMs = normalizeRetryDelay(options, attempt, error);\n          if (waitMs > 0) {\n            await delay(waitMs, signal);\n          }\n        }\n      }\n    };\n\n    try {\n      const p = execute();\n      currentPromise = p;\n      const result = await p;\n\n      if (signal.aborted) return;\n\n      set(state, {\n        value: result,\n        loading: false,\n        error: undefined\n      });\n    } catch (err: any) {\n      if (signal.aborted) return;\n      set(state, (prev) => ({\n        ...prev,\n        loading: false,\n        error: err\n      }));\n    }\n  };\n\n  createEffect(() => {\n    const s = srcFn();\n    load(s);\n  });\n\n  onCleanup(() => {\n    if (abortController) abortController.abort();\n  });\n\n  const read = () => {\n    const s = get(state);\n    if (s.error) throw s.error;\n    if (s.loading && currentPromise) {\n      throw currentPromise;\n    }\n    return s.value;\n  };\n\n  read.loading = () => get(state).loading;\n  read.error = () => get(state).error;\n  read.refetch = () => load(srcFn());\n  read.mutate = (val: T | undefined) =>\n    set(state, { value: val, loading: false, error: undefined });\n  read.state = state;\n\n  return read as Resource<T>;\n}\n","import { v, get, set, type VAtom } from './core';\nimport { createContext } from './context';\nimport { resolve, type VNode } from './jsx-runtime';\n\n// Define context symbols\nexport const SUSPENSE_CONTEXT_SYMBOL = Symbol.for(\"vitrio.suspense\");\nexport const ERROR_BOUNDARY_CONTEXT_SYMBOL = Symbol.for(\"vitrio.error\");\n\n// --- Suspense ---\n\nexport interface SuspenseContextValue {\n  increment: () => void;\n  decrement: () => void;\n  state: VAtom<number>;\n}\n\nexport const SuspenseContext = createContext<SuspenseContextValue | undefined>(undefined, SUSPENSE_CONTEXT_SYMBOL);\n\nexport function Suspense(props: { fallback?: any; children: any }): VNode {\n  const pendingCount = v(0);\n\n  const contextValue: SuspenseContextValue = {\n    increment: () => set(pendingCount, (c) => c + 1),\n    decrement: () => set(pendingCount, (c) => Math.max(0, c - 1)),\n    state: pendingCount\n  };\n\n  const renderer = () => {\n    const count = get(pendingCount);\n    if (count > 0) {\n      return resolve(props.fallback);\n    }\n\n    try {\n      return resolve(props.children);\n    } catch (err: any) {\n      if (err && typeof err.then === 'function') {\n        // Handle initial render suspension\n        contextValue.increment();\n        err.then(contextValue.decrement, contextValue.decrement);\n        return resolve(props.fallback);\n      }\n      throw err;\n    }\n  };\n\n  return (\n    // @ts-ignore\n    {\n      _brand: \"component\",\n      type: SuspenseContext.Provider,\n      props: {\n        value: contextValue,\n        children: renderer\n      }\n    }\n  );\n}\n\n// --- ErrorBoundary ---\n\nexport interface ErrorBoundaryContextValue {\n  handleError: (error: any) => void;\n}\n\nexport const ErrorBoundaryContext = createContext<ErrorBoundaryContextValue | undefined>(undefined, ERROR_BOUNDARY_CONTEXT_SYMBOL);\n\nexport function ErrorBoundary(props: { fallback: (err: any) => any; children: any }): VNode {\n  const error = v<any>(null);\n\n  const contextValue: ErrorBoundaryContextValue = {\n    handleError: (err: any) => set(error, err)\n  };\n\n  const renderer = () => {\n    const err = get(error);\n    if (err) {\n      const fallbackFn = props.fallback;\n      return resolve(typeof fallbackFn === 'function' ? fallbackFn(err) : fallbackFn);\n    }\n\n    try {\n      return resolve(props.children);\n    } catch (e: any) {\n      // Handle initial render error\n      set(error, e);\n      const fallbackFn = props.fallback;\n      return resolve(typeof fallbackFn === 'function' ? fallbackFn(e) : fallbackFn);\n    }\n  };\n\n  return (\n    // @ts-ignore\n    {\n      _brand: \"component\",\n      type: ErrorBoundaryContext.Provider,\n      props: {\n        value: contextValue,\n        children: renderer\n      }\n    }\n  );\n}\n","/**\n * V-Signal Render\n * Mount components to DOM - Solid-style (create once, update bindings)\n */\n\nimport { cleanupNode, resolve, type VNode } from './jsx-runtime'\nimport { createRoot } from './core'\n\n/**\n * Render a component to a container\n * DOM is created once. Reactive updates happen via fine-grained bindings in jsx-runtime.\n * @example\n * render(<App />, document.getElementById('root'))\n */\nexport function render(component: VNode | (() => VNode), container: Element | null): (() => void) {\n  if (!container) {\n    throw new Error('Container element not found')\n  }\n  \n  // Dispose previous root if exists\n  const oldDispose = (container as any)._dispose;\n  if (typeof oldDispose === 'function') {\n    oldDispose();\n    (container as any)._dispose = undefined;\n  }\n\n  // Clear container once with cleanup to drop subscriptions\n  while (container.firstChild) {\n    cleanupNode(container.firstChild)\n    container.removeChild(container.firstChild)\n  }\n  \n  // Create DOM once - reactive bindings in jsx-runtime handle updates\n  // Run in root scope to manage lifecycle of effects\n  return createRoot((dispose) => {\n    (container as any)._dispose = dispose;\n\n    // If component is a function (e.g. () => <App /> or App), execute it first\n    // to get the VNode/Descriptor.\n    let root = component;\n    if (typeof root === 'function') {\n      root = (root as () => VNode)();\n    }\n\n    const result = resolve(root);\n    if (result) {\n      container.appendChild(result)\n    }\n\n    return dispose;\n  });\n}\n\n/**\n * Mount shorthand\n */\nexport const mount = render\n","import { h } from \"./jsx-runtime\";\nimport type { ActionApi } from \"./router\";\n\nexport function Form<TInput = any>(props: {\n  action: ActionApi<TInput, any>;\n  value: TInput | (() => TInput);\n  children: any;\n  disabled?: boolean;\n}) {\n  const onSubmit = (e: SubmitEvent) => {\n    e.preventDefault();\n    const val = typeof props.value === \"function\" ? (props.value as any)() : props.value;\n    props.action.run(val);\n  };\n\n  const disabled = props.disabled ?? false;\n\n  // Note: we intentionally keep this minimal; users can style/compose as needed.\n  return h(\n    \"form\",\n    {\n      onSubmit,\n      // Disable pointer interactions when pending (best-effort)\n      \"aria-busy\": () => (props.action.pending() ? \"true\" : \"false\"),\n      style: () =>\n        props.action.pending() || disabled\n          ? \"pointer-events:none;opacity:0.7;\"\n          : \"\",\n    },\n    props.children,\n  );\n}\n"],"mappings":"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"}